<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

### Table of Contents

-   [@airtable/blocks][1]
    -   [SDK][2]
    -   [GlobalConfig][3]
    -   [settingsButton][4]
    -   [Viewport][5]
-   [@airtable/blocks/models][6]
    -   [fieldTypes][7]
    -   [generateGuid][8]
    -   [viewTypes][9]
    -   [recordColoring][10]
    -   [AbstractModel][11]
    -   [AbstractModelWithAsyncData][12]
    -   [Aggregator][13]
    -   [Base][14]
    -   [Session][15]
    -   [Cursor][16]
    -   [Field][17]
    -   [RecordQueryResult][18]
    -   [Record][19]
    -   [Table][20]
    -   [View][21]
    -   [ViewMetadataQueryResult][22]
    -   [Watchable][23]
-   [@airtable/blocks/ui][24]
    -   [initializeBlock][25]
    -   [CSS & external scripts][26]
    -   [Color utilities][27]
    -   [React hooks for working with Airtable data][28]
    -   [expandRecord][29]
    -   [expandRecordList][30]
    -   [expandRecordPickerAsync][31]
    -   [AutocompletePopover][32]
    -   [Button][33]
    -   [CellRenderer][34]
    -   [ChoiceToken][35]
    -   [CollaboratorToken][36]
    -   [ColorPalette][37]
    -   [ConfirmationDialog][38]
    -   [Dialog][39]
    -   [FieldPicker][40]
    -   [Icon][41]
    -   [Input][42]
    -   [Link][43]
    -   [Loader][44]
    -   [Popover][45]
    -   [ProgressBar][46]
    -   [RecordCard][47]
    -   [Select][48]
    -   [SelectButtons][49]
    -   [TablePicker][50]
    -   [Toggle][51]
    -   [Tooltip][52]
    -   [ViewPicker][53]
    -   [ViewportConstraint][54]

## @airtable/blocks

### SDK

#### [import {base} from '@airtable/blocks';][14]

An instance of [Base][14] representing the current Airtable base. If you're writing a React
Component, you might want to use the [useBase][55] hook rather than importing `base` directly.

#### [import {globalConfig} from '@airtable/blocks';][3]

[GlobalConfig][3] is a key-value store shared between every user of a particular installation of
your block. Use it for storing block configuration.

#### [import {session} from '@airtable/blocks';][15]

An instance of [Session][15], containing information about the current user's session. If you're
writing a React Component, you might want to use the [useSession][56] hook rather than importing
`session` directly.

#### [import {cursor} from '@airtable/blocks';][16]

An instance of [Cursor][16], containing information about the table & view that the user currently
has open in the main Airtable app, as well as which records they have selected.

#### [import {viewport} from '@airtable/blocks';][5]

Controls the block's viewport within Airtable. Use this to fullscreen the block and add size
constraints. See [Viewport][5].

#### [import {settingsButton} from '@airtable/blocks';][4]

Controls the block's settings button. See [SettingsButton][57].

#### import {reload} from '@airtable/blocks';

Call this function to reload the block frame:

```js
import {reload} from '@airtable/blocks';
reload();
```

#### import {installationId} from '@airtable/blocks';

A unique ID for this block installation.

#### import {localStorage, sessionStorage} from '@airtable/blocks';

Wrappers for [window.localStorage][58] and [window.sessionStorage][59] which will automatically fall
back to an in-memory alternative when the browser version is unavailable.

#### [import \* as models from '@airtable/blocks/models';][6]

Model classes, field types, view types, and utilities for working with record coloring and record
aggregation.

#### [import \* as UI from '@airtable/blocks/ui';][24]

React component library, hooks for integrating Airtable data with React components, and UI helpers.

### GlobalConfig

#### GlobalConfig

**Extends Watchable**

A key-value store for persisting configuration options for a block installation.

The contents will be synced in real-time to all logged-in users of the installation. Contents will
not be updated in real-time when the installation is running in a publicly shared base, or in
development mode.

Any key can be watched to know when the value of the key changes.

You should not need to construct this object yourself.

##### Examples

```javascript
import {globalConfig} from '@airtable/blocks';
```

##### canSet

Returns `true` if the current user can set the global config value at `key`, `false` otherwise.

###### Parameters

-   `key` **([string][60] \| [Array][61]&lt;[string][60]>)** A string for the top-level key, or an
    array of strings describing the path to the value.

###### Examples

```javascript
import {globalConfig} from '@airtable/blocks';

if (globalConfig.canSet('favoriteColor')) {
    globalConfig.set('favoriteColor', 'purple');
}
```

Returns **[boolean][62]** `true` if the current user can set the global config value at `key`, and
`false` otherwise.

##### canSetPaths

Returns `true` if the current user can perform the specified updates to global config, `false`
otherwise.

###### Parameters

-   `updates` **[Array][61]&lt;{path: ([string][60] \| [Array][61]&lt;[string][60]>), value:
    [GlobalConfigValue][63]}>** The paths and values to set.

###### Examples

```javascript
import {globalConfig} from '@airtable/blocks';

const updates = [
    {path: ['topLevelKey1', 'nestedKey1'], value: 'foo'},
    {path: ['topLevelKey2', 'nestedKey2'], value: 'bar'},
];
if (globalConfig.canSetPaths(updates)) {
    globalConfig.setPaths(updates);
}
```

Returns **[boolean][62]** `true` if the current user can perform the specified updates to global
config, `false` otherwise.

##### get

Get the value at a path. Throws an error if the path is invalid.

###### Parameters

-   `key` **([string][60] \| [Array][61]&lt;[string][60]>)** A string for the top-level key, or an
    array of strings describing the path to the value.

###### Examples

```javascript
import {globalConfig} from '@airtable/blocks';

const topLevelValue = globalConfig.get('topLevelKey');
const nestedValue = globalConfig.get(['topLevelKey', 'nested', 'deeply']);
```

Returns **([GlobalConfigValue][63] | void)** The value at the provided path, or `undefined` if no
value exists at that path.

##### set

Sets a value at a path. Throws an error if the path or value is invalid.

###### Parameters

-   `key` **([string][60] \| [Array][61]&lt;[string][60]>)** A string for the top-level key, or an
    array of strings describing the path to set.
-   `value` **([GlobalConfigValue][63] | void)** The value to set at the specified path. Use
    `undefined` to delete the value at the given path.

###### Examples

```javascript
import {globalConfig} from '@airtable/blocks';

if (globalConfig.canSet('favoriteColor')) {
    globalConfig.set('favoriteColor', 'purple');
}
```

Returns **{}**

##### setPaths

Sets multiple values. Throws if any path or value is invalid.

###### Parameters

-   `updates` **[Array][61]&lt;{path: ([string][60] \| [Array][61]&lt;[string][60]>), value:
    [GlobalConfigValue][63]}>** The paths and values to set.

###### Examples

```javascript
import {globalConfig} from '@airtable/blocks';

const updates = [
    {path: ['topLevelKey1', 'nestedKey1'], value: 'foo'},
    {path: ['topLevelKey2', 'nestedKey2'], value: 'bar'},
];
if (globalConfig.canSetPaths(updates)) {
    globalConfig.setPaths(updates);
}
```

Returns **{}**

##### unwatch

Unwatch keys watched with `.watch`.

Should be called with the same arguments given to `.watch`.

###### Parameters

-   `keys` **(WatchableGlobalConfigKey | [Array][61]&lt;WatchableGlobalConfigKey>)** the keys to
    unwatch
-   `callback` **[Function][64]** the function passed to `.watch` for these keys
-   `context` **[Object][65]??** the context that was passed to `.watch` for this `callback`

Returns **[Array][61]&lt;WatchableGlobalConfigKey>** the array of keys that were unwatched

##### watch

Get notified of changes to global config.

You can watch any top-level key in global config. Use '\*' to watch every change.

Every call to `.watch` should have a matching call to `.unwatch`.

###### Parameters

-   `keys` **(WatchableGlobalConfigKey | [Array][61]&lt;WatchableGlobalConfigKey>)** the keys to
    watch
-   `callback` **[Function][64]** a function to call when those keys change
-   `context` **[Object][65]??** an optional context for `this` in `callback`.

Returns **[Array][61]&lt;WatchableGlobalConfigKey>** the array of keys that were watched

#### GlobalConfigKey

Type: ([string][60] \| [Array][61]&lt;[string][60]>)

#### GlobalConfigValue

Type: (null | [boolean][62] \| [number][66] \| [string][60] \|
[Array][61]&lt;[GlobalConfigValue][63]> | [Object][65]&lt;[string][60], [GlobalConfigValue][63]>)

### settingsButton

**Extends Watchable**

Interface to the settings button that lives outside the block's viewport.

Watch `click` to handle click events on the button.

#### Examples

```javascript
import {settingsButton} from '@airtable/blocks';
settingsButton.isVisible = true;
settingsButton.watch('click', () => {
    alert('Clicked!');
});
```

#### unwatch

Unwatch keys watched with `.watch`.

Should be called with the same arguments given to `.watch`.

##### Parameters

-   `keys` **(WatchableSettingsButtonKey | [Array][61]&lt;WatchableSettingsButtonKey>)** the keys to
    unwatch
-   `callback` **[Function][64]** the function passed to `.watch` for these keys
-   `context` **[Object][65]??** the context that was passed to `.watch` for this `callback`

Returns **[Array][61]&lt;WatchableSettingsButtonKey>** the array of keys that were unwatched

#### watch

Get notified of changes to the settings button.

Watchable keys are:

-   `'isVisible'`
-   `'click'`

Every call to `.watch` should have a matching call to `.unwatch`.

##### Parameters

-   `keys` **(WatchableSettingsButtonKey | [Array][61]&lt;WatchableSettingsButtonKey>)** the keys to
    watch
-   `callback` **[Function][64]** a function to call when those keys change
-   `context` **[Object][65]??** an optional context for `this` in `callback`.

Returns **[Array][61]&lt;WatchableSettingsButtonKey>** the array of keys that were watched

#### isVisible

Whether the settings button is being shown. Set to `true` to show the settings button. Can be
watched.

Type: [boolean][62]

Returns **[boolean][62]**

### Viewport

**Extends Watchable**

Information about the current viewport

#### Examples

```javascript
import {viewport} from '@airtable/blocks';
```

#### addMaxFullscreenSize

Add a maximum fullscreen size constraint. Use \`.maxFullscreenSize`` to get the aggregate of all
added constraints.

##### Parameters

-   `sizeConstraint` **{width: ([number][66] | null), height: ([number][66] | null)}** The width and
    height constraints to add. Both `width` and `height` are optional - if either is set to null,
    that means there is no max size in that dimension.

Returns **[Function][64]** A function that can be called to remove the fullscreen size constraint
that was added.

#### addMinSize

Add a minimum frame size constraint. Use \`.minSize`` to get the aggregate of all added constraints.

##### Parameters

-   `sizeConstraint` **{width: ([number][66] | null), height: ([number][66] | null)}** The width and
    height constraints to add. Both `width` and `height` are optional - if either is set to null,
    that means there is no min size in that dimension.

Returns **[Function][64]** A function that can be called to remove the size constraint that was
added.

#### enterFullscreenIfPossible

Request to enter fullscreen mode.

May fail if another block is fullscreen or this block doesn't have permission to fullscreen itself.
Watch `isFullscreen` to know if the request succeeded.

#### exitFullscreen

Request to exit fullscreen mode

#### isFullscreen

Boolean to denote whether the block is currently fullscreen.

Can be watched.

Type: [boolean][62]

Returns **[boolean][62]** `true` if the block is fullscreen, `false` otherwise.

#### isSmallerThanMinSize

Boolean to denote whether the block frame is smaller than the `minSize`.

Type: [boolean][62]

Returns **[boolean][62]** `true` if the block frame is smaller than `minSize`, `false` otherwise.

#### maxFullscreenSize

The maximum dimensions of the block when it is in fullscreen mode. Returns the smallest set of
dimensions added with [Viewport#addMaxFullscreenSize][67].

If `width` or `height` is null, it means there is no max size constraint on that dimension. If
`maxFullscreenSize` would be smaller than [Viewport#minSize][68], it is constrained to be at least
`minSize`.

Type: ViewportSizeConstraint

Returns **{width: ([number][66] | null), height: ([number][66] | null)}** maxSize

#### minSize

The minimum dimensions of the block - if the viewport gets smaller than this size, an overlay will
be shown asking the user to resize the block to be bigger.

Type: ViewportSizeConstraint

Returns **{width: ([number][66] | null), height: ([number][66] | null)}** The largest set of
dimensions added with addMinSize. If `width` or `height` is null, it means there is no minSize
constraint on that dimension.

#### size

The current size of the block frame.

Can be watched.

Type: {width: [number][66], height: [number][66]}

Returns **{width: [number][66], height: [number][66]}** The current size of the block frame.

#### unwatch

Unwatch keys watched with `.watch`.

Should be called with the same arguments given to `.watch`.

##### Parameters

-   `keys` **(WatchableViewportKey | [Array][61]&lt;WatchableViewportKey>)** the keys to unwatch
-   `callback` **[Function][64]** the function passed to `.watch` for these keys
-   `context` **[Object][65]??** the context that was passed to `.watch` for this `callback`

Returns **[Array][61]&lt;WatchableViewportKey>** the array of keys that were unwatched

#### watch

Get notified of changes to the viewport.

Watchable keys are:

-   `'isFullscreen'`
-   `'size'`
-   `'minSize'`
-   `'maxFullscreenSize'`

Every call to `.watch` should have a matching call to `.unwatch`.

##### Parameters

-   `keys` **(WatchableViewportKey | [Array][61]&lt;WatchableViewportKey>)** the keys to watch
-   `callback` **[Function][64]** a function to call when those keys change
-   `context` **[Object][65]??** an optional context for `this` in `callback`.

Returns **[Array][61]&lt;WatchableViewportKey>** the array of keys that were watched

## @airtable/blocks/models

### fieldTypes

An enum of Airtable's field types

#### Examples

```javascript
import {fieldTypes} from '@airtable/blocks/models';
const numberFields = myTable.fields.filter(field => field.type === fieldTypes.NUMBER);
```

#### fieldTypes.AUTO_NUMBER

Automatically incremented unique counter for each record.

##### Cell value format

```js
number;
```

##### Options

None

#### fieldTypes.BARCODE

Use the Airtable iOS or Android app to scan barcodes.

##### Cell value format

```js
{
    // the text value of the barcode
    text: string,
    // the type of barcode
    type?: string,
}
```

##### Options

None

#### fieldTypes.CHECKBOX

A checkbox.

##### Cell value format

```js
boolean;
```

This field is "true" when checked and otherwise empty.

##### Options

```js
{
    // an [Icon](#icon) name
    icon: string,
    // the color of the check box
    color: Color,
}
```

#### fieldTypes.COUNT

Count the number of linked records.

##### Cell value format

```js
number;
```

##### Options

```js
{
   // is the field currently valid (false if e.g. the linked record field is switched to a different type)
   isValid: boolean,
   // the linked record field in this table that we're counting
   recordLinkFieldId: FieldId,
}
```

#### fieldTypes.CREATED_TIME

The time the record was created in UTC.

##### Cell value format

```js
string;
```

An [ISO 8601][69] formatted date time.

##### Options

```js
{
    result: {
        type: 'date' | 'dateTime',
        options: DateOrDateTimeFieldOptions,
    },
}
```

See [fieldTypes.DATE][70] and [fieldTypes.DATE_TIME][71] for `result` options.

#### fieldTypes.CURRENCY

An amount of a currency.

##### Cell value format

```js
number;
```

##### Options

```js
{
    precision: number,
    symbol: string,
}
```

#### fieldTypes.DATE

A date.

##### Cell value format

```js
string;
```

An [ISO 8601][69] formatted date.

##### Options

```js
{
    dateFormat: {
        name: 'local' | 'friendly' | 'us' | 'european' | 'iso',
        // a date format string as documented here: https://momentjs.com/docs/#/parsing/string-format/
        format: string,
    }
}
```

#### fieldTypes.DATE_TIME

A date & time.

##### Cell value format

```js
string;
```

An [ISO 8601][69] formatted date time.

##### Options

```js
{
    dateFormat: {
        name: 'local' | 'friendly' | 'us' | 'european' | 'iso',
        // a date format string as documented here: https://momentjs.com/docs/#/parsing/string-format/
        format: string,
    },
    timeFormat: {
        name: '12hour' | '24hour',
        // a time format string as documented here: https://momentjs.com/docs/#/parsing/string-format/
        format: string,
    },
    timeZone: 'utc' | 'client',
}
```

#### fieldTypes.DURATION

A duration of time in seconds.

##### Cell value format

```js
number;
```

##### Options

```js
{
    // a time format string as documented here: https://momentjs.com/docs/#/parsing/string-format/
    durationFormat: string,
}
```

#### fieldTypes.EMAIL

A valid email address (e.g. andrew@example.com).

##### Cell value format

```js
string;
```

##### Options

None

#### fieldTypes.FORMULA

Compute a value in each record based on other fields in the same record.

##### Cell value format

```js
any;
```

Check `options.result` to know the resulting field type.

##### Options

```js
{
    // false if the formula contains an error
    isValid: boolean,
    // the other fields in the record that are used in the formula
    fieldIdsReferencedByFormulaText: Array<FieldId>,
    // the resulting field type and options returned by the formula
    result: {
        // the field type of the formula result
        type: string,
        // that types options
        options?: any,
    },
}
```

#### fieldTypes.LAST_MODIFIED_TIME

Shows the date and time that a record was most recently modified in any editable field or just in
specific editable fields.

##### Cell value format

```js
string;
```

An [ISO 8601][69] formatted date time.

##### Options

```js
{
    // false if the formula contains an error
    isValid: boolean,
    // the fields to check the last modified time of
    fieldIdsReferencedByFormulaText: Array<FieldId>,
    // the cell value result type
    result: {
        type: 'date' | 'dateTime',
        options: DateOrDateTimeFieldOptions,
    },
}
```

See [fieldTypes.DATE][70] and [fieldTypes.DATE_TIME][71] for `result` options.

#### fieldTypes.LOOKUP

Lookup a field on linked records.

##### Cell value format

UNSTABLE

##### Options

UNSTABLE

#### fieldTypes.MULTILINE_TEXT

A long text field that can span multiple lines.

###### Cell value format

```js
string;
```

Multiple lines of text, which may contain "mention tokens", e.g.
`<airtable:mention id="menE1i9oBaGX3DseR">@Alex</airtable:mention>`

###### Options

None

#### fieldTypes.MULTIPLE_ATTACHMENTS

Attachments allow you to add images, documents, or other files which can then be viewed or
downloaded.

##### Cell value format

```js
Array<{
    // unique attachment id
    id: string,
    // url, e.g. "https://dl.airtable.com/foo.jpg"
    url: string,
    // filename, e.g. "foo.jpg"
    filename: string,
    // file size, in bytes
    size?: number,
    // content type, e.g. "image/jpeg"
    type?: string,
    // thumbnails if available
    thumbnails: {
        small?: {
            url: string,
            width?: number,
            height?: number,
        },
        large?: {
            url: string,
            width?: number,
            height?: number,
        },
        full?: {
            url: string,
            width?: number,
            height?: number,
        },
    },
}>
```

##### Options

None

#### fieldTypes.MULTIPLE_COLLABORATORS

A collaborator field lets you add collaborators to your records. Collaborators can optionally be
notified when they're added.

##### Cell value format

```js
Array<{
    id: string,
    email: string,
    name?: string,
    profilePicUrl?: string,
}>
```

Array of selected choices.

##### Options

```js
{
    choices: Array<{
        id: string,
        email: string,
        name?: string,
        profilePicUrl?: string,
    }>,
}
```

#### fieldTypes.MULTIPLE_RECORD_LINKS

Link to another record.

##### Cell value format

```js
Array<{
    id: RecordId,
    name: string,
}>
```

Array of selected record IDs and their primary cell values from the linked table.

##### Options

```js
{
    // The ID of the table this field links to
    linkedTableId: TableId,
    // The ID of the field in the linked table that links back to this one
    inverseLinkFieldId?: FieldId,
    // The ID of the view in the linked table to use when showing a list of records to select from
    viewIdForRecordSelection?: ViewId,
}
```

#### fieldTypes.MULTIPLE_SELECTS

Multiple select allows you to select one or more predefined options from a dropdown

##### Cell value format

```js
Array<{
    id: string,
    name: string,
    color?: Color,
}>
```

Array of selected choices.

##### Options

```js
{
    choices: Array<{
        id: string,
        name: string,
        color?: Color,
    }>,
}
```

#### fieldTypes.NUMBER

A number.

##### Cell value format

```js
number;
```

##### Options

```js
{
    precision: number,
}
```

#### fieldTypes.PERCENT

A percentage - 0 is 0%, 1 is 100%.

##### Cell value format

```js
number;
```

##### Options

```js
{
    precision: number,
}
```

#### fieldTypes.PHONE_NUMBER

A telephone number (e.g. (415) 555-9876).

##### Cell value format

```js
string;
```

##### Options

None

#### fieldTypes.RATING

A rating (e.g. stars out of 5)

##### Cell value format

```js
number;
```

##### Options

```js
{
    // the [Icon](#icon) name used to display the rating
    icon: string,
    // the maximum value for the rating
    max: number,
    // the color of selected icons
    color: Color,
}
```

#### fieldTypes.ROLLUP

A rollup allows you to summarize data from records that are linked to this table.

##### Cell value format

```js
any;
```

Check `options.result` to know the resulting field type.

##### Options

```js
{
    // false if the formula contains an error
    isValid: boolean,
    // the linked record field in this table that this field is summarizing.
    recordLinkFieldId: FieldId,
    // the field id in the linked table that this field is summarizing.
    fieldIfInLinkedTable: FieldId,
    // the other fields in the record that are used in the formula
    fieldIdsReferencedByFormulaText: Array<FieldId>,
    // the resulting field type and options returned by the formula
    result: {
        // the field type of the formula result
        type: string,
        // that types options
        options?: any,
    },
}
```

#### fieldTypes.SINGLE_COLLABORATOR

A collaborator field lets you add collaborators to your records. Collaborators can optionally be
notified when they're added.

##### Cell value format

```js
{
    id: string,
    email: string,
    name?: string,
    profilePicUrl?: string,
}
```

The currently selected choice.

##### Options

```js
{
    choices: Array<{
        id: string,
        email: string,
        name?: string,
        profilePicUrl?: string,
    }>,
}
```

#### fieldTypes.SINGLE_LINE_TEXT

A single line of text.

##### Cell value format

```js
string;
```

##### Options

None

#### fieldTypes.SINGLE_SELECT

Single select allows you to select a single option from predefined options in a dropdown.

##### Cell value format

```js
{
    id: string,
    name: string,
    color?: Color
}
```

The currently selected choice.

##### Options

```js
{
    choices: Array<{
        id: string,
        name: string,
        color?: Color,
    }>,
}
```

#### fieldTypes.URL

A valid URL (e.g. airtable.com or [https://airtable.com/universe][72]).

###### Cell value format

```js
string;
```

###### Options

None

### generateGuid

Helper to generate a GUID.

#### Examples

```javascript
import {generateGuid} from '@airtable/blocks/models';
const id = generateGuid();
```

Returns **[string][60]**

### viewTypes

An enum of Airtable's view types

#### Examples

```javascript
import {viewTypes} from '@airtable/blocks/models';
const gridViews = myTable.views.filter(view => view.type === viewTypes.GRID);
```

#### viewTypes.CALENDAR

#### viewTypes.FORM

#### viewTypes.GALLERY

#### viewTypes.GRID

#### viewTypes.KANBAN

### recordColoring

Record coloring configuration used with [RecordQueryResult][18]s.

#### recordColoring.modes

Record coloring config creators.

##### Examples

```javascript
import {recordColoring} from '@airtable/blocks/models';

// no record coloring:
const recordColorMode = recordColoring.modes.none();
// color by select field:
const recordColorMode = recordColoring.modes.bySelectField(someSelectField);
// color from view:
const recordColorMode = recordColoring.modes.byView(someView);

// with a query result:
const queryResult = table.selectRecords({recordColorMode});
```

#### recordColoring.modes.bySelectField

##### Parameters

-   `selectField` **[Field][73]**

Returns **{type: recordColoring.ModeTypes.BY_SELECT_FIELD, selectField: [Field][73]}**

#### recordColoring.modes.byView

##### Parameters

-   `view` **[View][74]**

Returns **{type: recordColoring.ModeTypes.BY_VIEW, view: [View][74]}**

#### recordColoring.modes.none

Returns **{type: recordColoring.ModeTypes.NONE}**

#### recordColoring.ModeTypes

An enum of the different types of [recordColoring.modes][75]

#### recordColoring.ModeTypes.BY_SELECT_FIELD

#### recordColoring.ModeTypes.BY_VIEW

#### recordColoring.ModeTypes.NONE

### AbstractModel

**Extends Watchable**

Abstract superclass for all models. You won't use this class directly.

#### id

Type: [string][60]

Returns **[string][60]** The ID for this model.

#### isDeleted

A boolean denoting whether the model has been deleted.

In general, it's best to avoid keeping a reference to an object past the current event loop, since
it may be deleted and trying to access any data of a deleted object (other than its ID) will throw.
But if you keep a reference, you can use `isDeleted` to check that it's safe to access the model's
data.

Type: [boolean][62]

Returns **[boolean][62]** `true` if the model has been deleted, and `false` otherwise.

#### toString

Returns **[string][60]** A string representation of the model for use in debugging.

### AbstractModelWithAsyncData

**Extends AbstractModel**

Abstract superclass for all block SDK models that need to fetch async data.

#### Parameters

-   `baseData` **BaseData**
-   `modelId` **[string][60]**

#### isDataLoaded

Type: [boolean][62]

Returns **[boolean][62]**

#### loadDataAsync

Will cause all the async data to be fetched and retained. Every call to `loadDataAsync` should have
a matching call to `unloadData`.

Returns a Promise that will resolve once the data is loaded.

#### unloadData

#### unwatch

Unwatching a key that needs to load data asynchronously will automatically cause the data to be
released. Once the data is available, the callback will be called.

##### Parameters

-   `keys` **(WatchableKey | [Array][61]&lt;WatchableKey>)**
-   `callback` **[Function][64]**
-   `context` **[Object][65]??**

Returns **[Array][61]&lt;WatchableKey>**

#### watch

Watching a key that needs to load data asynchronously will automatically cause the data to be
fetched. Once the data is available, the callback will be called.

##### Parameters

-   `keys` **(WatchableKey | [Array][61]&lt;WatchableKey>)**
-   `callback` **[Function][64]**
-   `context` **[Object][65]??**

Returns **[Array][61]&lt;WatchableKey>**

### Aggregator

Aggregators can be used to compute aggregates for cell values.

Type: {key: [string][60], displayName: [string][60], shortDisplayName: [string][60], aggregate:
function (records: [Array][61]&lt;[Record][76]>, field: [Field][73]): any, aggregateToString:
function (records: [Array][61]&lt;[Record][76]>, field: [Field][73]): [string][60]}

#### Properties

-   `key` **[string][60]**
-   `displayName` **[string][60]**
-   `shortDisplayName` **[string][60]**
-   `aggregate` **function (records: [Array][61]&lt;[Record][76]>, field: [Field][73]): any**
-   `aggregateToString` **function (records: [Array][61]&lt;[Record][76]>, field: [Field][73]):
    [string][60]**

#### Examples

```javascript
// To get a list of aggregators supported for a specific field:
const fieldAggregators = myField.availableAggregators;

// To compute the total attachment size of an attachment field:
import {aggregators} from '@airtable/blocks/models';
const aggregator = aggregators.totalAttachmentSize;
const value = aggregator.aggregate(myRecords, myAttachmentField);
const valueAsString = aggregate.aggregateToString(myRecords, myAttachmentField);
```

### Base

**Extends AbstractModel**

Model class representing a base.

#### Examples

```javascript
import {base} from '@airtable/blocks';

console.log('The name of your base is', base.name);
```

#### activeCollaborators

Type: [Array][61]&lt;CollaboratorData>

##### Examples

```javascript
import {base} from '@airtable/blocks';
console.log(base.activeCollaborators[0].email);
```

Returns **[Array][61]&lt;CollaboratorData>** The users who have access to this base.

#### getCollaboratorById

##### Parameters

-   `collaboratorId` **UserId** The ID of the user.

Returns **CollaboratorData** The user matching the given ID. Throws if that user does not exist or
does not have access to this base. Use [getCollaboratorByIdIfExists][77] instead if you are unsure
whether a collaborator with the given ID exists and has access to this base.

#### getCollaboratorByIdIfExists

##### Parameters

-   `collaboratorId` **UserId** The ID of the user.

Returns **(CollaboratorData | null)** The user matching the given ID, or `null` if that user does
not exist or does not have access to this base.

#### getTableById

##### Parameters

-   `tableId` **[string][60]** The ID of the table.

Returns **[Table][78]** The table matching the given ID. Throws if that table does not exist in this
base. Use [getTableByIdIfExists][79] instead if you are unsure whether a table exists with the given
ID.

#### getTableByIdIfExists

##### Parameters

-   `tableId` **[string][60]** The ID of the table.

Returns **([Table][78] | null)** The table matching the given ID, or `null` if that table does not
exist in this base.

#### getTableByName

##### Parameters

-   `tableName` **[string][60]** The name of the table you're looking for.

Returns **[Table][78]** The table matching the given name. Throws if no table exists with that name
in this base. Use [getTableByNameIfExists][80] instead if you are unsure whether a table exists with
the given name.

#### getTableByNameIfExists

##### Parameters

-   `tableName` **[string][60]** The name of the table you're looking for.

Returns **([Table][78] | null)** The table matching the given name, or `null` if no table exists
with that name in this base.

#### id

##### Examples

```javascript
import {base} from '@airtable/blocks';
console.log(base.id);
// => 'appxxxxxxxxxxxxxx'
```

Returns **[string][60]** This base's ID.

#### name

Type: [string][60]

##### Examples

```javascript
import {base} from '@airtable/blocks';
console.log('The name of your base is', base.name);
```

Returns **[string][60]** The name of the base.

#### tables

Type: [Array][61]&lt;[Table][78]>

##### Examples

```javascript
import {base} from '@airtable/blocks';
console.log(`You have ${base.tables.length} tables`);
```

Returns **[Array][61]&lt;[Table][78]>** The tables in this base. Can be watched to know when tables
are created, deleted, or reordered in the base.

#### unwatch

Unwatch keys watched with `.watch`.

Should be called with the same arguments given to `.watch`.

##### Parameters

-   `keys` **(WatchableBaseKey | [Array][61]&lt;WatchableBaseKey>)** the keys to unwatch
-   `callback` **[Function][64]** the function passed to `.watch` for these keys
-   `context` **[Object][65]??** the context that was passed to `.watch` for this `callback`

Returns **[Array][61]&lt;WatchableBaseKey>** the array of keys that were unwatched

#### watch

Get notified of changes to the base.

Watchable keys are:

-   `'name'`
-   `'tables'`
-   `'collaborators'`

Every call to `.watch` should have a matching call to `.unwatch`.

##### Parameters

-   `keys` **(WatchableBaseKey | [Array][61]&lt;WatchableBaseKey>)** the keys to watch
-   `callback` **[Function][64]** a function to call when those keys change
-   `context` **[Object][65]??** an optional context for `this` in `callback`.

Returns **[Array][61]&lt;WatchableBaseKey>** the array of keys that were watched

### Session

**Extends AbstractModel**

Model class representing the current user's session.

#### Examples

```javascript
import {session} from '@airtable/blocks';

if (session.currentUser !== null) {
    console.log("The current user's name is", session.currentUser.name);
} else {
    console.log('This block is being viewed in a public share');
}
```

#### currentUser

Type: (CollaboratorData | null)

##### Examples

```javascript
import {session} from '@airtable/blocks';
if (session.currentUser) {
    console.log(session.currentUser.id);
    console.log(session.currentUser.email);
    console.log(session.currentUser.name);
}
```

Returns **(CollaboratorData | null)** The current user, or `null` if the block is running in a
publicly shared base.

#### unwatch

Unwatch keys watched with `.watch`.

Should be called with the same arguments given to `.watch`.

##### Parameters

-   `keys` **(WatchableSessionKey | [Array][61]&lt;WatchableSessionKey>)** the keys to unwatch
-   `callback` **[Function][64]** the function passed to `.watch` for these keys
-   `context` **[Object][65]??** the context that was passed to `.watch` for this `callback`

Returns **[Array][61]&lt;WatchableSessionKey>** the array of keys that were unwatched

#### watch

Get notified of changes to the session.

Watchable keys are:

-   `'permissionLevel'`

Every call to `.watch` should have a matching call to `.unwatch`.

##### Parameters

-   `keys` **(WatchableSessionKey | [Array][61]&lt;WatchableSessionKey>)** the keys to watch
-   `callback` **[Function][64]** a function to call when those keys change
-   `context` **[Object][65]??** an optional context for `this` in `callback`.

Returns **[Array][61]&lt;WatchableSessionKey>** the array of keys that were watched

### Cursor

**Extends AbstractModelWithAsyncData**

Contains information about the state of the user's current interactions in Airtable

#### Examples

```javascript
import {cursor} from '@airtable/blocks';
```

#### activeTableId

The currently active table ID.

Can be watched.

Type: (TableId | null)

Returns **(TableId | null)** The currently active table ID. Can return null when the active table
has changed and is not yet loaded.

#### activeViewId

The currently active view ID. This will always be a view belonging to `activeTableId`

Can be watched.

Type: (ViewId | null)

Returns **(ViewId | null)** The currently active view ID. Can return null when the active view has
changed and is not yet loaded.

#### isRecordSelected

Checks whether a given record is selected.

##### Parameters

-   `recordOrRecordId` **([Record][76] \| [string][60])** The record or record ID to check for.

Returns **[boolean][62]** `true` if the given record is selected, `false` otherwise.

#### selectedRecordIds

The record IDs of all currently selected records, or an empty array if no records are selected.

Can be watched.

Type: [Array][61]&lt;RecordId>

Returns **[Array][61]&lt;RecordId>** The record IDs of all currently selected records, or an empty
array if no records are selected.

#### unwatch

Unwatch keys watched with `.watch`.

Should be called with the same arguments given to `.watch`.

##### Parameters

-   `keys` **(WatchableCursorKey | [Array][61]&lt;WatchableCursorKey>)** the keys to unwatch
-   `callback` **[Function][64]** the function passed to `.watch` for these keys
-   `context` **[Object][65]??** the context that was passed to `.watch` for this `callback`

Returns **[Array][61]&lt;WatchableCursorKey>** the array of keys that were unwatched

#### watch

Get notified of changes to the cursor.

Watchable keys are:

-   `'selectedRecordIds'`
-   `'activeTableId'`
-   `'activeViewId'`
-   `'isDataLoaded'`

Every call to `.watch` should have a matching call to `.unwatch`.

##### Parameters

-   `keys` **(WatchableCursorKey | [Array][61]&lt;WatchableCursorKey>)** the keys to watch
-   `callback` **[Function][64]** a function to call when those keys change
-   `context` **[Object][65]??** an optional context for `this` in `callback`.

Returns **[Array][61]&lt;WatchableCursorKey>** the array of keys that were watched

### Field

**Extends AbstractModel**

Model class representing a field in a table.

#### Examples

```javascript
import {base} from '@airtable/blocks';

const table = base.getTableByName('Table 1');
const field = table.getFieldByName('Name');
console.log('The type of this field is', field.type);
```

#### availableAggregators

Type: [Array][61]&lt;[Aggregator][81]>

##### Examples

```javascript
const fieldAggregators = myField.availableAggregators;
```

Returns **[Array][61]&lt;[Aggregator][81]>** A list of available aggregators given this field's
configuration.

#### convertStringToCellValue

Given a string, will attempt to parse it and return a valid cell value for the field's current
config.

##### Parameters

-   `string` **[string][60]** The string to parse.

##### Examples

```javascript
const inputString = '42';
const cellValue = myNumberField.convertStringToCellValue(inputString);
console.log(cellValue === 42);
// => true
```

Returns **any** The parsed cell value, or `null` if unable to parse the given string.

#### id

##### Examples

```javascript
console.log(myField.id);
// => 'fldxxxxxxxxxxxxxx'
```

Returns **[string][60]** This field's ID.

#### isAggregatorAvailable

##### Parameters

-   `aggregator` **([Aggregator][81] \| [string][60])** The aggregator object or aggregator key.

##### Examples

```javascript
import {aggregators} from '@airtable/blocks/models';
const aggregator = aggregators.totalAttachmentSize;

// Using an aggregator object
console.log(myAttachmentField.isAggregatorAvailable(aggregator));
// => true

// Using an aggregator key
console.log(mySingleLineTextField.isAggregatorAvailable('totalAttachmentSize'));
// => false
```

Returns **[boolean][62]** `true` if the given aggregator is available for this field, `false`
otherwise.

#### isComputed

Type: [boolean][62]

##### Examples

```javascript
console.log(mySingleLineTextField.isComputed);
// => false
console.log(myAutoNumberField.isComputed);
// => true
```

Returns **[boolean][62]** `true` if this field is computed, `false` otherwise. A field is "computed"
if it's value is not set by user input (e.g. autoNumber, formula, etc.). Can be watched.

#### isDeleted

True if this field has been deleted.

In general, it's best to avoid keeping a reference to a field past the current event loop, since it
may be deleted and trying to access any data of a deleted field (other than its ID) will throw. But
if you do keep a reference, you can use `isDeleted` to check that it's safe to access the field's
data.

##### Examples

```javascript
if (!myField.isDeleted) {
    // Do things with myField
}
```

Returns **[boolean][62]** `true` if the field has been deleted, `false` otherwise.

#### isPrimaryField

Type: [boolean][62]

Returns **[boolean][62]** `true` if this field is its parent table's primary field, `false`
otherwise. Should never change because the primary field of a table cannot change.

#### name

Type: [string][60]

##### Examples

```javascript
console.log(myField.name);
// => 'Name'
```

Returns **[string][60]** The name of the field. Can be watched.

#### options

Type: ({} | null)

##### Examples

```javascript
import {fieldTypes} from '@airtable/blocks/models';

if (myField.type === fieldTypes.CURRENCY) {
    console.log(myField.options.symbol);
    // => '$'
}
```

Returns **({} | null)** The configuration options of the field. The structure of the field's options
depend on the field's type. Can be watched.

#### type

Type: [string][60]

##### Examples

```javascript
console.log(myField.type);
// => 'singleLineText'
```

Returns **[string][60]** The type of the field. Can be watched.

#### unwatch

Unwatch keys watched with `.watch`.

Should be called with the same arguments given to `.watch`.

##### Parameters

-   `keys` **(WatchableFieldKey | [Array][61]&lt;WatchableFieldKey>)** the keys to unwatch
-   `callback` **[Function][64]** the function passed to `.watch` for these keys
-   `context` **[Object][65]??** the context that was passed to `.watch` for this `callback`

Returns **[Array][61]&lt;WatchableFieldKey>** the array of keys that were unwatched

#### watch

Get notified of changes to the field.

Watchable keys are:

-   `'name'`
-   `'type'`
-   `'options'`
-   `'isComputed'`

Every call to `.watch` should have a matching call to `.unwatch`.

##### Parameters

-   `keys` **(WatchableFieldKey | [Array][61]&lt;WatchableFieldKey>)** the keys to watch
-   `callback` **[Function][64]** a function to call when those keys change
-   `context` **[Object][65]??** an optional context for `this` in `callback`.

Returns **[Array][61]&lt;WatchableFieldKey>** the array of keys that were watched

### RecordQueryResult

#### RecordQueryResult

**Extends AbstractModelWithAsyncData**

A RecordQueryResult represents a set of records. It's a little bit like a one-off View in Airtable:
it contains a bunch of records, filtered to a useful subset of the records in the table. Those
records can be sorted according to your specification, and they can be colored by a select field or
using the color from a view. Just like a view, you can either have all the fields in a table
available, or you can just ask for the fields that are relevant to you. There are two types of
QueryResult:

-   [TableOrViewQueryResult][82] is the most common, and is a query result filtered to all the
    records in a specific [Table][20] or [View][21]. You can get one of these with
    `table.selectRecords()` or `view.selectRecords()`.
-   [LinkedRecordsQueryResult][83] is a query result of all the records in a particular [linked
    record cell][84]. You can get one of these with `record.selectLinkedRecordsFromCell(someField)`.

Once you've got a query result, you need to load it before you can start working with it. When
you're finished, unload it:

```js
// query for all the records in "myTable"
const queryResult = myTable.selectRecords();

// load the data in the query result:
await queryResult.loadDataAsync();

// work with the data in the query result
doSomething(queryResult);

// when you're done, unload the data:
queryResult.unloadData();
```

If you're using a query result in a React component, you don't need to worry about this. Just use
[useRecords][85], [useRecordIds][86], [useRecordById][87] or [useLoadable][88], which will handle
all that for you.

Whilst loaded, a query result will automatically keep up to date with what's in Airtable: records
will get added or removed, the order will change, cell values will be updated, etc. Again, if you're
writing a React component then our hooks will look after that for you. If not, you can get notified
of these changes with `.watch()`.

When calling a `.select*` method, you can pass in a number of options:

##### sorts

Pass an array of sorts to control the order of records within the query result. The first sort in
the array has the highest priority. If you don't specify sorts, the query result will use the
inherent order of the source model: the same order you'd see in the main UI for views and linked
record fields, and an arbitrary (but stable) order for tables.

```js
view.selectRecords({
    sorts: [
        // sort by someField in ascending order...
        {field: someField},
        // then by someOtherField in descending order
        {field: someOtherField, direction: 'desc'},
    ],
});
```

##### fields

Generally, it's a good idea to load as little data into your block as possible - Airtable bases can
get pretty big, and we have to keep all that information in memory and up to date if you ask for it.
The fields option lets you make sure that only data relevant to you is loaded.

You can specify fields with a [Field][17], by ID, or by name:

````js
view.selectRecords({
    fields: [
        // we want to only load fieldA:
        fieldA,
        // the field with this id:
        'fldXXXXXXXXXXXXXX',
        // and the field named 'Rating':
        'Rating',
    ],
});

##### recordColorMode
Just like a view in Airtable, you can control the colors of records in a field. There are three
supported record color modes:

By taking the colors the records have according to the rules of a specific view:
```js
import {recordColoring} from '@airtable/blocks/models';

someView.selectRecords({
    recordColorMode: recordColoring.modes.byView(someView),
});
````

Based on the color of a single select field in the table:

```js
import {recordColoring} from '@airtable/blocks/models';

someView.selectRecords({
    recordColorMode: recordColoring.modes.bySelectField(someSelectField),
});
```

Or with no color at all (the default):

```js
import {recordColoring} from '@airtable/blocks/models';

someView.selectRecords({
    recordColorMode: recordColoring.modes.none(),
});
```

##### fields

The fields that were used to create this QueryResult. Null if fields were not specified, which means
the QueryResult will load all fields in the table.

Type: ([Array][61]&lt;[Field][73]> | null)

Returns **([Array][61]&lt;[Field][73]> | null)**

##### getRecordById

Get a specific record in the query result, or throws if that record doesn't exist or is filtered
out. Throws if data is not loaded yet. Watch using `'recordIds'`.

###### Parameters

-   `recordId` **RecordId** the ID of the [Record][19] you want

Returns **[Record][76]** the record

##### getRecordByIdIfExists

Get a specific record in the query result, or null if that record doesn't exist or is filtered out.
Throws if data is not loaded yet. Watch using `'recordIds'`.

###### Parameters

-   `recordId` **RecordId** the ID of the [Record][19] you want

Returns **([Record][76] | null)** the record

##### getRecordColor

Get the color of a specific record in the query result. Throws if the record isn't in the
RecordQueryResult. Watch with the `'recordColors'` and `'recordIds` keys.

###### Parameters

-   `recordOrRecordId` **(RecordId | [Record][76])** the record or record ID you want the color of.

Returns **([Color][89] | null)** a [Color][90], or null if the record has no color in this query
result.

##### hasRecord

Check to see if a particular record or record id is present in this query result. Returns false if
the record has been deleted or is filtered out.

###### Parameters

-   `recordOrRecordId` **(RecordId | [Record][76])** the record or record id to check the presence
    of

Returns **[boolean][62]** whether the record exists in this query result

##### loadDataAsync

Loads all data for the query result.

Every call to `loadDataAsync` should have a matching call to `unloadData`.

Returns **[Promise][91]&lt;void>** A promise that will resolve once the data is loaded.

##### recordIds

The record IDs in this QueryResult. Throws if data is not loaded yet. Can be watched.

Type: [Array][61]&lt;RecordId>

Returns **[Array][61]&lt;RecordId>**

##### records

The records in this RecordQueryResult. Throws if data is not loaded yet. Can be watched.

Type: [Array][61]&lt;[Record][76]>

Returns **[Array][61]&lt;[Record][76]>** all of the records in this query result

##### unloadData

Unloads data for the query result.

Every call to `loadDataAsync` should have a matching call to `unloadData`.

Returns **void**

##### unwatch

Unwatch keys watched with `.watch`.

Should be called with the same arguments given to `.watch`.

Unwatching a key that needs to load data asynchronously will automatically cause the data to be
unloaded.

###### Parameters

-   `keys` **(WatchableRecordQueryResultKey | [Array][61]&lt;WatchableRecordQueryResultKey>)** the
    keys to unwatch
-   `callback` **[Function][64]** the function passed to `.watch` for these keys
-   `context` **[Object][65]??** the context that was passed to `.watch` for this `callback`

Returns **[Array][61]&lt;WatchableRecordQueryResultKey>** the array of keys that were unwatched

##### watch

Get notified of changes to the query result.

Watchable keys are:

-   `'records'`
-   `'recordIds'`
-   `'cellValues'`
-   `'recordColors'`
-   `'isDataLoaded'`
-   `'cellValuesInField:' + someFieldId`

Every call to `.watch` should have a matching call to `.unwatch`.

Watching a key that needs to load data asynchronously will automatically cause the data to be
fetched. Once the data is available, the `callback` will be called.

###### Parameters

-   `keys` **(WatchableRecordQueryResultKey | [Array][61]&lt;WatchableRecordQueryResultKey>)** the
    keys to watch
-   `callback` **[Function][64]** a function to call when those keys change
-   `context` **[Object][65]??** an optional context for `this` in `callback`.

Returns **[Array][61]&lt;WatchableRecordQueryResultKey>** the array of keys that were watched

#### TableOrViewQueryResult

**Extends RecordQueryResult**

Represents a set of records directly from a view or table. See [RecordQueryResult][18] for main
documentation.

Do not instantiate. You can get instances of this class by calling `table.selectRecords` or
`view.selectRecords`.

##### Parameters

-   `sourceModel` **([Table][78] \| [View][74])**
-   `recordStore` **RecordStore**
-   `opts` **RecordQueryResultOpts?**

##### fields

The fields that were used to create this RecordQueryResult. Null if fields were not specified, which
means the RecordQueryResult will load all fields in the table.

Type: ([Array][61]&lt;[Field][73]> | null)

Returns **([Array][61]&lt;[Field][73]> | null)**

##### recordIds

The record IDs in this RecordQueryResult. Throws if data is not loaded yet. Can be watched.

Type: [Array][61]&lt;[string][60]>

Returns **[Array][61]&lt;[string][60]>**

#### LinkedRecordsQueryResult

**Extends RecordQueryResult**

Represents a set of records from a LinkedRecord cell value. See [RecordQueryResult][18] for main
documentation.

Do not instantiate. You can get instances of this class by calling
`record.getLinkedRecordsFromCell`.

##### Parameters

-   `record` **[Record][76]**
-   `field` **[Field][73]**
-   `opts` **RecordQueryResultOpts**

##### fields

Type: ([Array][61]&lt;[Field][73]> | null)

Returns **([Array][61]&lt;[Field][73]> | null)** The fields that were used to create this
LinkedRecordsQueryResult.

##### isValid

Is the query result currently valid? This value always starts as 'true', but can become false if the
field config changes to link to a different table or a type other than MULTIPLE_RECORD_LINKS. Once
`isValid` has become false, it will never become true again. Many fields will throw on attempting to
access them, and watches will no longer fire.

Type: [boolean][62]

Returns **[boolean][62]** whether the query result is valid

##### recordIds

Watchable.

Type: [Array][61]&lt;[string][60]>

Returns **[Array][61]&lt;[string][60]>** Ordered array of all the linked record ids.

##### records

Watchable.

Type: [Array][61]&lt;[Record][76]>

Returns **[Array][61]&lt;[Record][76]>** Ordered array of all the linked records.

### Record

**Extends AbstractModel**

Model class representing a record in a table.

Do not instantiate. You can get instances of this class by calling `table.selectRecords` or
`view.selectRecords` and using the resulting {@RecordQueryResult}.

#### commentCount

Type: [number][66]

##### Examples

```javascript
const comentCount = myRecord.commentCount;
console.log(`This record has ${commentCount} ${commentCount === 1 ? 'comment' : 'comments'}`);
```

Returns **[number][66]** The number of comments on this record.

#### createdTime

Type: [Date][92]

##### Examples

```javascript
console.log(`This record was created at ${myRecord.createdTime.toISOString()}`);
```

Returns **[Date][92]** The created time of this record.

#### getAttachmentClientUrlFromCellValueUrl

Returns a URL that is suitable for rendering an attachment on the current client. The URL that is
returned will only work for the current user.

##### Parameters

-   `attachmentId` **[string][60]** The ID of the attachment.
-   `attachmentUrl` **[string][60]** The attachment's URL (which is not suitable for rendering on
    the client).

##### Examples

```javascript
import React from 'react';

function RecordAttachments(props) {
    const {record, attachmentField} = props;
    const attachmentCellValue = record.getCellValue(attachmentField);
    if (attachmentCellValue === null) {
        return null;
    }
    return (
        <div>
            {attachmentCellValue.map(attachmentObj => {
                const clientUrl = record.getAttachmentClientUrlFromCellValueUrl(
                    attachmentObj.id,
                    attachmentObj.url,
                );
                return <img key={attachmentObj.id} src={clientUrl} width={200} />;
            })}
        </div>
    );
}
```

Returns **[string][60]** A URL that is suitable for rendering on the current client.

#### getCellValue

Gets a specific cell value in this record.

##### Parameters

-   `fieldOrFieldIdOrFieldName` **([Field][73] | FieldId | [string][60])** The field (or field ID or
    field name) whose cell value you'd like to get.

##### Examples

```javascript
const cellValue = myRecord.getCellValue(mySingleLineTextField);
console.log(cellValue);
// => 'cell value'
```

Returns **any** The cell value in the given field.

#### getCellValueAsString

Gets a specific cell value in this record, formatted as a `string`.

##### Parameters

-   `fieldOrFieldIdOrFieldName` **([Field][73] \| [string][60])** The field (or field ID or field
    name) whose cell value you'd like to get.

##### Examples

```javascript
const cellValueAsString = myRecord.getCellValueAsString(myNumberField);
console.log(cellValueAsString);
// => '42'
```

Returns **[string][60]** The cell value in the given field, formatted as a `string`.

#### getColorHexInView

Gets the CSS hex string for this record in a given view.

Can be watched with the 'colorInView:\${ViewId}' key.

##### Parameters

-   `viewOrViewIdOrViewName` **([View][74] \| [string][60])** The view (or view ID or view name) to
    use for record coloring.

Returns **([string][60] | null)** The CSS hex color for this record in the given view, or null if
the record has no color in that view.

#### getColorInView

Gets the color of this record in a given view.

Can be watched with the 'colorInView:\${ViewId}' key.

##### Parameters

-   `viewOrViewIdOrViewName` **([View][74] \| [string][60])** The view (or view ID or view name) to
    use for record coloring.

Returns **([Color][89] | null)** The color of this record in the given view, or null if the record
has no color in that view.

#### id

##### Examples

```javascript
console.log(myRecord.id);
// => 'recxxxxxxxxxxxxxx'
```

Returns **[string][60]** This record's ID.

#### isDeleted

True if this record has been deleted.

In general, it's best to avoid keeping a reference to a record past the current event loop, since it
may be deleted and trying to access any data of a deleted record (other than its ID) will throw. But
if you do keep a reference, you can use `isDeleted` to check that it's safe to access the record's
data.

##### Examples

```javascript
if (!myRecord.isDeleted) {
    // Do things with myRecord
}
```

Returns **[boolean][62]** `true` if the record has been deleted, `false` otherwise.

#### primaryCellValue

Gets the primary cell value in this record.

Type: any

##### Examples

```javascript
console.log(myRecord.primaryCellValue);
// => 'primary cell value'
```

Returns **any** The primary cell value in this record.

#### primaryCellValueAsString

Gets the primary cell value in this record, formatted as a `string`.

Type: [string][60]

##### Examples

```javascript
console.log(myRecord.primaryCellValueAsString);
// => '42'
```

Returns **[string][60]** The primary cell value in this record, formatted as a `string`.

#### selectLinkedRecordsFromCell

Select records referenced in a `multipleRecordLinks` cell value. Returns a query result. See
[RecordQueryResult][18] for more.

##### Parameters

-   `fieldOrFieldIdOrFieldName` **([Field][73] \| [string][60])** The `multipleRecordLinks` field
    (or field ID or field name) to use.
-   `opts` **RecordQueryResultOpts** Options for the query, such as sorts and fields. (optional,
    default `{}`)

Returns **[LinkedRecordsQueryResult][93]** A query result containing the records in the given
`multipleRecordLinks` field.

#### unwatch

Unwatch keys watched with `.watch`.

Should be called with the same arguments given to `.watch`.

##### Parameters

-   `keys` **(WatchableRecordKey | [Array][61]&lt;WatchableRecordKey>)** the keys to unwatch
-   `callback` **[Function][64]** the function passed to `.watch` for these keys
-   `context` **[Object][65]??** the context that was passed to `.watch` for this `callback`

Returns **[Array][61]&lt;WatchableRecordKey>** the array of keys that were unwatched

#### url

Type: [string][60]

##### Examples

```javascript
console.log(myRecord.url);
// => 'https://airtable.com/tblxxxxxxxxxxxxxx/recxxxxxxxxxxxxxx'
```

Returns **[string][60]** The URL for the record. You can visit this URL in the browser to be taken
to the record in the Airtable UI.

#### watch

Get notified of changes to the record.

Watchable keys are:

-   `'primaryCellValue'`
-   `'commentCount'`
-   `'cellValues'`
-   `'cellValueInField:' + someFieldId`
-   `'colorInView:' + someViewId`

Every call to `.watch` should have a matching call to `.unwatch`.

##### Parameters

-   `keys` **(WatchableRecordKey | [Array][61]&lt;WatchableRecordKey>)** the keys to watch
-   `callback` **[Function][64]** a function to call when those keys change
-   `context` **[Object][65]??** an optional context for `this` in `callback`.

Returns **[Array][61]&lt;WatchableRecordKey>** the array of keys that were watched

### Table

**Extends AbstractModel**

Model class representing a table. Every [Base][14] has one or more tables.

#### fields

Type: [Array][61]&lt;[Field][73]>

##### Examples

```javascript
console.log(`This table has ${myTable.fields.length} fields`);
```

Returns **[Array][61]&lt;[Field][73]>** The fields in this table. The order is arbitrary, since
fields are only ordered in the context of a specific view.Can be watched to know when fields are
created or deleted.

#### getFieldById

##### Parameters

-   `fieldId` **FieldId** The ID of the field.

##### Examples

```javascript
const fieldId = 'fldxxxxxxxxxxxxxx';
const field = myTable.getFieldById(fieldId);
console.log(field.name);
// => 'Name'
```

Returns **[Field][73]** The field matching the given ID. Throws if that field does not exist in this
table. Use [getFieldByIdIfExists][94] instead if you are unsure whether a field exists with the
given ID.

#### getFieldByIdIfExists

##### Parameters

-   `fieldId` **FieldId** The ID of the field.

##### Examples

```javascript
const fieldId = 'fldxxxxxxxxxxxxxx';
const field = myTable.getFieldByIdIfExists(fieldId);
if (field !== null) {
    console.log(field.name);
} else {
    console.log('No field exists with that ID');
}
```

Returns **([Field][73] | null)** The field matching the given ID, or `null` if that field does not
exist in this table.

#### getFieldByName

##### Parameters

-   `fieldName` **[string][60]** The name of the field you're looking for.

##### Examples

```javascript
const field = myTable.getFieldByName('Name');
console.log(field.id);
// => 'fldxxxxxxxxxxxxxx'
```

Returns **[Field][73]** The field matching the given name. Throws if no field exists with that name
in this table. Use [getFieldByNameIfExists][95] instead if you are unsure whether a field exists
with the given name.

#### getFieldByNameIfExists

##### Parameters

-   `fieldName` **[string][60]** The name of the field you're looking for.

##### Examples

```javascript
const field = myTable.getFieldByNameIfExists('Name');
if (field !== null) {
    console.log(field.id);
} else {
    console.log('No field exists with that name');
}
```

Returns **([Field][73] | null)** The field matching the given name, or `null` if no field exists
with that name in this table.

#### getFirstViewOfType

Returns the first view in the table where the type is one of `allowedViewTypes`.

##### Parameters

-   `allowedViewTypes` **([Array][61]&lt;ViewType> | ViewType)** An array of view types or a single
    view type to match against.
-   `preferredViewOrViewId` **([View][74] | ViewId | null)?** If a view or view ID is supplied and
    that view exists & has the correct type, that view will be returned before checking the other
    views in the table.

##### Examples

```javascript
import {viewTypes} from '@airtable/blocks/models';
const firstCalendarView = myTable.getFirstViewOfType(viewTypes.CALENDAR);
if (firstCalendarView !== null) {
    console.log(firstCalendarView.name);
} else {
    console.log('No calendar views exist in the table');
}
```

Returns **([View][74] | null)** The first view where the type is one of `allowedViewTypes` or `null`
if no such view exists in the table.

#### getViewById

##### Parameters

-   `viewId` **ViewId** The ID of the view.

##### Examples

```javascript
const viewId = 'viwxxxxxxxxxxxxxx';
const view = myTable.getViewById(viewId);
console.log(view.name);
// => 'Grid view'
```

Returns **[View][74]** The view matching the given ID. Throws if that view does not exist in this
table. Use [getViewByIdIfExists][96] instead if you are unsure whether a view exists with the given
ID.

#### getViewByIdIfExists

##### Parameters

-   `viewId` **ViewId** The ID of the view.

##### Examples

```javascript
const viewId = 'viwxxxxxxxxxxxxxx';
const view = myTable.getViewByIdIfExists(viewId);
if (view !== null) {
    console.log(view.name);
} else {
    console.log('No view exists with that ID');
}
```

Returns **([View][74] | null)** The view matching the given ID, or `null` if that view does not
exist in this table.

#### getViewByName

##### Parameters

-   `viewName` **[string][60]** The name of the view you're looking for.

##### Examples

```javascript
const view = myTable.getViewByName('Name');
console.log(view.id);
// => 'viwxxxxxxxxxxxxxx'
```

Returns **[View][74]** The view matching the given name. Throws if no view exists with that name in
this table. Use [getViewByNameIfExists][97] instead if you are unsure whether a view exists with the
given name.

#### getViewByNameIfExists

##### Parameters

-   `viewName` **[string][60]** The name of the view you're looking for.

##### Examples

```javascript
const view = myTable.getViewByNameIfExists('Name');
if (view !== null) {
    console.log(view.id);
} else {
    console.log('No view exists with that name');
}
```

Returns **([View][74] | null)** The view matching the given name, or `null` if no view exists with
that name in this table.

#### id

##### Examples

```javascript
console.log(myTable.id);
// => 'tblxxxxxxxxxxxxxx'
```

Returns **[string][60]** This table's ID.

#### isDeleted

True if this table has been deleted.

In general, it's best to avoid keeping a reference to a table past the current event loop, since it
may be deleted and trying to access any data of a deleted table (other than its ID) will throw. But
if you do keep a reference, you can use `isDeleted` to check that it's safe to access the table's
data.

##### Examples

```javascript
if (!myTable.isDeleted) {
    // Do things with myTable
}
```

Returns **[boolean][62]** `true` if the table has been deleted, `false` otherwise.

#### name

Type: [string][60]

##### Examples

```javascript
console.log(myTable.name);
// => 'Table 1'
```

Returns **[string][60]** The name of the table. Can be watched.

#### primaryField

Type: [Field][73]

##### Examples

```javascript
console.log(myTable.primaryField.name);
// => 'Name'
```

Returns **[Field][73]** The table's primary field. Every table has exactly one primary field. The
primary field of a table will not change.

#### selectRecords

Select records from the table. Returns a query result. See [RecordQueryResult][18] for more.

##### Parameters

-   `opts` **RecordQueryResultOpts?** Options for the query, such as sorts and fields. (optional,
    default `{}`)

##### Examples

```javascript
import {UI} from '@airtable/blocks';
import React from 'react';

function TodoList() {
    const base = UI.useBase();
    const table = base.getTableByName('Tasks');

    const queryResult = table.selectRecords();
    const records = UI.useRecords(queryResult);

    return (
        <ul>
            {records.map(record => (
                <li key={record.id}>{record.primaryCellValueAsString || 'Unnamed record'}</li>
            ))}
        </ul>
    );
}
```

Returns **[TableOrViewQueryResult][98]** A query result.

#### unwatch

Unwatch keys watched with `.watch`.

Should be called with the same arguments given to `.watch`.

##### Parameters

-   `keys` **(WatchableTableKey | [Array][61]&lt;WatchableTableKey>)** the keys to unwatch
-   `callback` **[Function][64]** the function passed to `.watch` for these keys
-   `context` **[Object][65]??** the context that was passed to `.watch` for this `callback`

Returns **[Array][61]&lt;WatchableTableKey>** the array of keys that were unwatched

#### url

Type: [string][60]

##### Examples

```javascript
console.log(myTable.url);
// => 'https://airtable.com/tblxxxxxxxxxxxxxx'
```

Returns **[string][60]** The URL for the table. You can visit this URL in the browser to be taken to
the table in the Airtable UI.

#### views

Type: [Array][61]&lt;[View][74]>

##### Examples

```javascript
console.log(`This table has ${myTable.views.length} views`);
```

Returns **[Array][61]&lt;[View][74]>** The views in this table. Can be watched to know when views
are created, deleted, or reordered.

#### watch

Get notified of changes to the table.

Watchable keys are:

-   `'name'`
-   `'views'`
-   `'fields'`

Every call to `.watch` should have a matching call to `.unwatch`.

##### Parameters

-   `keys` **(WatchableTableKey | [Array][61]&lt;WatchableTableKey>)** the keys to watch
-   `callback` **[Function][64]** a function to call when those keys change
-   `context` **[Object][65]??** an optional context for `this` in `callback`.

Returns **[Array][61]&lt;WatchableTableKey>** the array of keys that were watched

### View

**Extends AbstractModel**

A class that represents an Airtable view. Every [Table][20] has one or more views.

#### id

##### Examples

```javascript
console.log(myView.id);
// => 'viwxxxxxxxxxxxxxx'
```

Returns **[string][60]** This view's ID.

#### isDeleted

True if this view has been deleted.

In general, it's best to avoid keeping a reference to a view past the current event loop, since it
may be deleted and trying to access any data of a deleted view (other than its ID) will throw. But
if you do keep a reference, you can use `isDeleted` to check that it's safe to access the view's
data.

##### Examples

```javascript
if (!myView.isDeleted) {
    // Do things with myView
}
```

Returns **[boolean][62]** `true` if the view has been deleted, `false` otherwise.

#### name

Type: [string][60]

##### Examples

```javascript
console.log(myView.name);
// => 'Grid view'
```

Returns **[string][60]** The name of the view. Can be watched.

#### selectMetadata

Select the field order and visible fields from the view. See {@ViewMetadataQueryResult} for more.

##### Examples

```javascript
const viewMetadata = view.selectMetadata();
await viewMetadata.loadDataAsync();

console.log('Visible fields:');
console.log(viewMetadata.visibleFields.map(field => field.name));
// => ['Field 1', 'Field 2', 'Field 3']

console.log('All fields:');
console.log(viewMetadata.allFields.map(field => field.name));
// => ['Field 1', 'Field 2', 'Field 3', 'Hidden field 4']

viewMetadata.unloadData();
```

Returns **[ViewMetadataQueryResult][99]** a {@ViewMetadataQueryResult}

#### selectRecords

Select records from the view. Returns a query result. See {@RecordQueryResult} for more.

##### Parameters

-   `opts` **RecordQueryResultOpts?** Options for the query, such as sorts and fields. (optional,
    default `{}`)

##### Examples

```javascript
import {UI} from '@airtable/blocks';
import React from 'react';

function TodoList() {
    const base = UI.useBase();
    const table = base.getTableByName('Tasks');
    const view = table.getViewByName('Grid view');

    const queryResult = view.selectRecords();
    const records = UI.useRecords(queryResult);

    return (
        <ul>
            {records.map(record => (
                <li key={record.id}>{record.primaryCellValueAsString || 'Unnamed record'}</li>
            ))}
        </ul>
    );
}
```

Returns **[TableOrViewQueryResult][98]** A record query result.

#### type

Type: ViewType

##### Examples

```javascript
console.log(myView.type);
// => 'kanban'
```

Returns **ViewType** The type of the view, such as Grid, Calendar, or Kanban. Should never change
because view types cannot be modified.

#### unwatch

Unwatch keys watched with `.watch`.

Should be called with the same arguments given to `.watch`.

##### Parameters

-   `keys` the keys to unwatch
-   `callback` the function passed to `.watch` for these keys
-   `context` the context that was passed to `.watch` for this `callback`

Returns **any** the array of keys that were unwatched

#### url

Type: [string][60]

##### Examples

```javascript
console.log(myView.url);
// => 'https://airtable.com/tblxxxxxxxxxxxxxx/viwxxxxxxxxxxxxxx'
```

Returns **[string][60]** The URL for the view. You can visit this URL in the browser to be taken to
the view in the Airtable UI.

#### watch

Get notified of changes to the view.

Watchable keys are:

-   `'name'`

Every call to `.watch` should have a matching call to `.unwatch`.

##### Parameters

-   `keys` the keys to watch
-   `callback` a function to call when those keys change
-   `context` an optional context for `this` in `callback`.

Returns **any** the array of keys that were watched

### ViewMetadataQueryResult

**Extends AbstractModelWithAsyncData**

Contains information about a view that isn't loaded by default e.g. field order and visible fields.

In a React component, you might want to use [useViewMetadata][100].

#### Parameters

-   `baseData` **BaseData**
-   `parentView` **[View][74]**
-   `viewDataStore` **ViewDataStore**

#### Examples

```javascript
const viewMetadata = view.selectMetadata();
await viewMetadata.loadDataAsync();

console.log(viewMetadata.visibleField);
// => [Field, Field, Field]

console.log(viewMetadata.allFields);
// => [Field, Field, Field, Field, Field]

viewMetadata.unloadData();
```

#### allFields

Returns every field in the table in the order they appear in this view. Watchable.

Type: [Array][61]&lt;[Field][73]>

Returns **[Array][61]&lt;[Field][73]>**

#### unwatch

Unwatch keys watched with `.watch`.

Should be called with the same arguments given to `.watch`.

##### Parameters

-   `keys` the keys to unwatch
-   `callback` the function passed to `.watch` for these keys
-   `context` the context that was passed to `.watch` for this `callback`

Returns **any** the array of keys that were unwatched

#### visibleFields

Returns every field visible in this view. Watchable.

Type: [Array][61]&lt;[Field][73]>

Returns **[Array][61]&lt;[Field][73]>**

#### watch

Get notified of changes to the view meta data.

Watchable keys are:

-   `'visibleFields'`
-   `'allFields'`
-   `'isDataLoaded'`

Every call to `.watch` should have a matching call to `.unwatch`.

##### Parameters

-   `keys` the keys to watch
-   `callback` a function to call when those keys change
-   `context` an optional context for `this` in `callback`.

Returns **any** the array of keys that were watched

### Watchable

Abstract superclass for watchable models. All watchable models expose `watch` and `unwatch` methods
that allow consumers to subscribe to changes to that model.

This class should not be used directly.

#### unwatch

Unwatch keys watched with `.watch`.

Should be called with the same arguments given to `.watch`.

##### Parameters

-   `keys` **(WatchableKey | [Array][61]&lt;WatchableKey>)** the keys to unwatch
-   `callback` **function (model: this, key: WatchableKey): any** the function passed to `.watch`
    for these keys
-   `context` **[Object][65]??** the context that was passed to `.watch` for this `callback`

Returns **[Array][61]&lt;WatchableKey>** the array of keys that were unwatched

#### watch

Get notified of changes to the model.

Every call to `.watch` should have a matching call to `.unwatch`.

##### Parameters

-   `keys` **(WatchableKey | [Array][61]&lt;WatchableKey>)** the keys to watch
-   `callback` **function (model: this, key: WatchableKey): any** a function to call when those keys
    change
-   `context` **[Object][65]??** an optional context for `this` in `callback`.

Returns **[Array][61]&lt;WatchableKey>** the array of keys that were watched

## @airtable/blocks/ui

### initializeBlock

`initializeBlock` takes the top-level React component in your tree and renders it. It is
conceptually similar to `ReactDOM.render`, but takes care of some Blocks-specific things.

#### Parameters

-   `getEntryElement` **function (): React.Node** A function that returns your React Node.

#### Examples

```javascript
import {initializeBlock} from '@airtable/blocks/ui';
import React from 'react';

function App() {
    return <div>Hello world 🚀</div>;
}

initializeBlock(() => <App />);
```

### CSS & external scripts

#### loadCSSFromString

Injects CSS from a string into the page.

##### Parameters

-   `css` **[string][60]** {string}

##### Examples

```javascript
import {loadCSSFromString} from '@airtable/blocks/ui';
loadCSSFromString('body { background: red; }');
```

Returns **[HTMLStyleElement][101]** the style tag inserted into the page.

#### loadCSSFromURLAsync

Injects CSS from a remote URL.

##### Parameters

-   `url` **[string][60]** {string}

##### Examples

```javascript
import {loadScriptFromURLAsync} from '@airtable/blocks/ui';
loadCSSFromURLAsync('https://example.com/style.css');
```

Returns **[Promise][91]&lt;[HTMLLinkElement][102]>** a Promise that resolves to the style tag
inserted into the page.

#### loadScriptFromURLAsync

Injects Javascript from a remote URL.

##### Parameters

-   `url` **[string][60]** {string}

##### Examples

```javascript
import {loadScriptFromURLAsync} from '@airtable/blocks/ui';
loadScriptFromURLAsync('https://example.com/script.js');
```

Returns **[Promise][91]&lt;[HTMLScriptElement][103]>** a Promise that resolves to the script tag
inserted into the page.

### Color utilities

#### Color

A value from the [colors][104] enum

Type: \$Values&lt;any>

#### RGB

Type: {r: [number][66], g: [number][66], b: [number][66]}

##### Properties

-   `r` **[number][66]**
-   `g` **[number][66]**
-   `b` **[number][66]**

#### colorUtils

Utilities for working with [Color][90] names from the [colors][104] enum.

##### getHexForColor

Given a [Color][90], return the hex color value for that color, or null if the value isn't a
[Color][90]

###### Parameters

-   `colorString` {Color}

###### Examples

```javascript
import {colorUtils, colors} from '@airtable/blocks/ui';

colorUtils.getHexForColor(colors.RED);
// => '#ef3061'

colorUtils.getHexForColor('uncomfortable beige');
// => null
```

Returns **([string][60] | null)**

##### getRgbForColor

Given a [Color][90], return an [RGB][105] object representing it, or null if the value isn't a
[Color][90]

###### Parameters

-   `colorString` {Color}

###### Examples

```javascript
import {colorUtils, colors} from '@airtable/blocks/ui';

colorUtils.getRgbForColor(colors.PURPLE_DARK_1);
// => {r: 107, g: 28, b: 176}

colorUtils.getRgbForColor('disgruntled pink');
// => null
```

Returns **([RGB][106] | null)**

##### shouldUseLightTextOnColor

Given a [Color][90], returns true or false to indicate whether that color should have light text on
top of it when used as a background color.

###### Parameters

-   `colorString` **[string][60]** {Color}

###### Examples

```javascript
import {colorUtils, colors} from '@airtable/blocks/ui';

colorUtils.shouldUseLightTextOnColor(colors.PINK_LIGHT_1);
// => false

colorUtils.shouldUseLightTextOnColor(colors.PINK_DARK_1);
// => true
```

Returns **[boolean][62]** boolean

#### colors

An enum of color names

##### colors.BLUE

##### colors.BLUE_BRIGHT

##### colors.BLUE_DARK_1

##### colors.BLUE_LIGHT_1

##### colors.BLUE_LIGHT_2

##### colors.CYAN

##### colors.CYAN_BRIGHT

##### colors.CYAN_DARK_1

##### colors.CYAN_LIGHT_1

##### colors.CYAN_LIGHT_2

##### colors.GRAY

##### colors.GRAY_BRIGHT

##### colors.GRAY_DARK_1

##### colors.GRAY_LIGHT_1

##### colors.GRAY_LIGHT_2

##### colors.GREEN

##### colors.GREEN_BRIGHT

##### colors.GREEN_DARK_1

##### colors.GREEN_LIGHT_1

##### colors.GREEN_LIGHT_2

##### colors.ORANGE

##### colors.ORANGE_BRIGHT

##### colors.ORANGE_DARK_1

##### colors.ORANGE_LIGHT_1

##### colors.ORANGE_LIGHT_2

##### colors.PINK

##### colors.PINK_BRIGHT

##### colors.PINK_DARK_1

##### colors.PINK_LIGHT_1

##### colors.PINK_LIGHT_2

##### colors.PURPLE

##### colors.PURPLE_BRIGHT

##### colors.PURPLE_DARK_1

##### colors.PURPLE_LIGHT_1

##### colors.PURPLE_LIGHT_2

##### colors.RED

##### colors.RED_BRIGHT

##### colors.RED_DARK_1

##### colors.RED_LIGHT_1

##### colors.RED_LIGHT_2

##### colors.TEAL

##### colors.TEAL_BRIGHT

##### colors.TEAL_DARK_1

##### colors.TEAL_LIGHT_1

##### colors.TEAL_LIGHT_2

##### colors.YELLOW

##### colors.YELLOW_BRIGHT

##### colors.YELLOW_DARK_1

##### colors.YELLOW_LIGHT_1

##### colors.YELLOW_LIGHT_2

### React hooks for working with Airtable data

React hooks are a new feature in React 16.8. They allow you to use state and other React features
without writing a class, and form the core of how you can connect React components to data from your
Airtable base when writing Blocks. If you've never used hooks before, don't worry - the React team
[has some great resources][107] for learning about them. You can use hooks with class components too
with the help of the [withHooks][108] higher-order component.

> **Important Note:** right now, most of these hooks cause your component to re-render, but return
> the same mutable instance of the underlying model. This means that it's often not safe to use
> these hooks with React.memo or React.PureComponent. This will change in a future release of
> @airtable/blocks. If you're not sure what this means or if it effects you, don't worry! Just avoid
> React.memo & React.PureComponent and you'll be fine.

#### useBase

A hook for connecting a React component to your Base's schema. This returns a [Base][14] instance
and will re-render your component whenever the base's schema changes. That means any change to your
base like tables being added or removed, fields getting renamed, etc. It excludes any change to the
actual records in the base.

useBase should meet most of your needs for working with Base schema. If you need more granular
control of when your component updates or want to do anything other than re-render, the lower level
[useWatchable][109] hook might help.

##### Examples

```javascript
import {useBase} from '@airtable/blocks/ui';

// renders a list of tables and automatically updates
function TableList() {
    const base = useBase();

    const tables = base.tables.map(table => {
        return <li key={table.id}>{table.name}</li>;
    });

    return <ul>{tables}</ul>;
}
```

Returns **[Base][110]** Base

#### useGlobalConfig

Returns the [GlobalConfig][3] and updates whenever any key in GlobalConfig changes.

##### Examples

```javascript
import {useGlobalConfig} from '@airtable/blocks/ui';

function SyncedCounter() {
    const globalConfig = useGlobalConfig();
    const count = globalConfig.get('count');

    const increment = () => globalConfig.set('count', count + 1);
    const decrement = () => globalConfig.set('count', count - 1);
    const isEnabled = globalConfig.canSet('count');

    return (
        <React.Fragment>
            <button onClick={decrement} disabled={!isEnabled}>
                -
            </button>
            {count}
            <button onClick={increment} disabled={!isEnabled}>
                +
            </button>
        </React.Fragment>
    );
}
```

Returns **[GlobalConfig][111]** the [GlobalConfig][3]

#### useRecords

A hook for working with all the records (including their colors and cell values) in a particular
query result. Automatically handles loading data in the query result and updating your component
when the underlying data changes.

This hook re-renders when any data concerning the records changing - that's useful, but can cause
re-renders quite often, meaning [useRecordIds][86] or [useRecordById][87] could be more appropriate
depending on your use-case.

##### Parameters

-   `queryResult` **(QueryResult | null)** the query result you want the records from

##### Examples

```javascript
import {useRecords, useBase} from '@airtable/blocks';

function RecordList() {
    // get a query result for the records in the first table
    const base = useBase();
    const table = base.tables[0];
    const queryResult = table.selectRecords();

    // grab all the records from that query result
    const records = useRecords(queryResult);

    // render a list of records:
    return (
        <ul>
            {records.map(record => {
                return <li key={record.id}>{record.primaryCellValueAsString}</li>;
            })}
        </ul>
    );
}
```

Returns **([Array][61]&lt;[Record][76]> | null)** the records in the query result, or null if no
query result was passed in.

#### useRecordIds

A hook for working with the set of record IDs in a particular query result. Automatically handles
loading data in the query result and updating your component when the underlying data changes.

This hook doesn't re-render when the data _inside_ the records changes - only when records are
added, removed, or re-ordered.

##### Parameters

-   `queryResult` **QueryResult** the query result you want the record ids from

##### Examples

```javascript
import {useRecordIds, useBase} from '@airtable/blocks/ui';

function RecordCount() {
    // get a query result for the records in the first table
    const base = useBase();
    const table = base.tables[0];
    const queryResult = table.selectRecords();

    // grab all the record ids from that QueryResult
    const recordIds = useRecordIds(queryResult);

    // return the count
    return (
        <span>
            record count in {table.name}: {recordIds.length}
        </span>
    );
}
```

Returns **([Array][61]&lt;RecordId> | null)** the array of record IDs in the query result, or null
if no query result was passed in.

#### useRecordById

A hook for working with a single record from a query result. Automatically handles loading data in
the query result and updating your component when the records cell values etc. change.

Often used with [useRecordIds][86] to render a list of records where each list item only updates
when the specific record it concerns changes.

##### Parameters

-   `queryResult` **(QueryResult | null)** the query result you want a record from
-   `recordId` **RecordId** the ID of the record you want from the query result

##### Examples

```javascript
import {useRecordById, useRecordIds, useBase} from '@airtable/blocks';

// this component concerns a single record - it only updates when that specific record updates
function RecordListItem({queryResult, recordId}) {
    const record = useRecordById(queryResult, recordId);
    return <li>{record.primaryCellValueAsString}</li>;
}

// this component renders a list of records, but doesn't update when their cell values change -
// that's left up to RecordListItem
function RecordList() {
    // get a query result for the records in the first table
    const base = useBase();
    const table = base.tables[0];
    const queryResult = table.selectRecords();

    // grab all the record ids from that query result
    const recordIds = useRecordIds(queryResult);

    // render a list of records:
    return (
        <ul>
            {recordsIds.map(recordId => {
                return (
                    <RecordListItem key={recordId} recordId={recordId} queryResult={queryResult} />
                );
            })}
        </ul>
    );
}
```

Returns **([Record][76] | null)** the record, or null if no query result was passed in or no record
with that ID exists in the query result

#### useSession

A hook for connecting a React component to the current [Session][15]. This returns a [Session][15]
instance and will re-render your component whenever the session changes (e.g. when the current
user's permissions change or when the current user's name changes).

useSession should meet most of your needs for working with Session. If you need more granular
control of when your component updates or want to do anything other than re-render, the lower level
[useWatchable][109] hook might help.

##### Examples

```javascript
import {CollaboratorToken, useSession} from '@airtable/blocks/ui';

// Says hello to the current user and updates in realtime if the current user's
// name or profile pic changes.
function CurrentUserGreeter() {
    const session = useSession();
    return (
        <React.Fragment>
            Hello,
            <CollaboratorToken collaborator={session.currentUser} />!
        </React.Fragment>
    );
}
```

Returns **[Session][112]** Session

#### useViewport

Returns the current [Viewport][5] object and updates whenever the viewport size, constraints, or
fullscreen status changes.

##### Examples

```javascript
import {useViewport} from '@airtable/blocks/ui';

function ViewportSize() {
    const viewport = useViewport();

    const toggleFullscreen = () => {
        if (viewport.isFullscreen) {
            viewport.exitFullscreen();
        } else {
            viewport.enterFullscreenIfPossible();
        }
    };

    return (
        <Fragment>
            <button onClick={toggleFullscreen}>Toggle fullscreen</button>
            viewport size: {viewport.size.width}x{viewport.size.height}
        </Fragment>
    );
}
```

Returns **[Viewport][113]** the current [Viewport][5]

#### useViewMetadata

Returns a [ViewMetadataQueryResult][22] for the specified view and re-renders whenever the view meta
data changes. Suspends if the view is not already loaded.

##### Parameters

-   `viewOrViewMetadataQueryResult` **any**

##### Examples

```javascript
import {useBase, useViewMetadata} from '@airtable/blocks/ui';

function ViewFields({view}) {
    const viewMetadata = useViewMetadata(view);

    return (
        <ul>
            {viewMetadata.visibleFields.map(field => (
                <li key={field.id}>{field.name}</li>
            ))}
        </ul>
    );
}
```

#### useWatchable

A React hook for watching data in Airtable models like [Table][20] and [Record][19]. Each model has
several watchable keys that can be used with this hook to have your component automatically
re-render when data in the models changes. You can also provide an optional callback if you need to
do anything other than re-render when the data changes.

This is a low-level tool that you should only use when you specifically need it. There are more
convenient model-specific hooks available:

-   For [Base][14], [Table][20], [View][21] & [Field][17], use [useBase][55]
-   For [RecordQueryResult][18] & [Record][19], use [useRecords][85], [useRecordIds][86], or
    [useRecordById][87]
-   For [Viewport][5], use [useViewport][114].

If you're writing a class component and still want to be able to use hooks, try [withHooks][108].

##### Parameters

-   `model` **[Watchable][115]?** the model to watch
-   `keys` **[Array][61]&lt;[string][60]?>** which keys we want to watch
-   `callback` **function (): any?** an optional callback to call when any of the watch keys change

##### Examples

```javascript
import {useWatchable} from '@airtable/blocks/ui';

function TableName({table}) {
    useWatchable(table, ['name']);
    return <span>The table name is {table.name}</span>;
}
```

```javascript
import {useWatchable} from '@airtable/blocks/ui';

function ActiveView({cursor}) {
    useWatchable(cursor, ['activeViewId'], () => {
        alert('active view changed!!!');
    });

    return <span>Active view id: {cursor.activeViewId}</span>;
}
```

#### useLoadable

When you're writing a block, not all of the data in your base is available to work with straight
away. We need to load it from Airtable first. This hook is a low-level tool for managing that. You
might not need to use it directly though - if you're working with a [RecordQueryResult][18], try
[useRecords][85], [useRecordIds][86], or [useRecordById][87] first.

When you need to use a loadable mode, `useLoadable(theModel)` will make sure that the model is
loaded when your component mounts, and unloaded when your component unmounts. By default, you don't
need to worry about waiting for the data to load - the hook uses React Suspense to make sure the
rest of your component doesn't run until the data is loaded. Whilst the data is loading, the entire
block will show a loading indicator. If you want to change where that indicator shows or how it
looks, use [&lt;React.Suspense />][116] around the component that uses the hook.

If you need more control (for example, if you have two models you want to load at the same time
rather than one after the other), you can pass `{shouldSuspend: false}` as a second argument to the
hook. In that case though, you should check each model's `.isDataLoaded` property before trying to
use the data you loaded.

##### Parameters

-   `model` **(QueryResult | [Cursor][117] | null)** the model to load.
-   `options` **[object][65]?** Optional options to control how the hook works (optional, default
    `{}`)
    -   `options.shouldSuspend` **[boolean][62]** pass {shouldSuspend: false} to disable suspense
        mode. If suspense is disabled, you need to manually check model.isDataLoaded so you don't
        use your model before it's ready. (optional, default `true`)

##### Examples

```javascript
import {cursor} from '@airtable/blocks';
import {useLoadable, useWatchable} from '@airtable/blocks/ui';

function SelectedRecordIds() {
    // load selected records
    useLoadable(cursor);

    // re-render whenever the list of selected records changes
    useWatchable(cursor, ['selectedRecordIds']);

    // render the list of selected record ids
    return <div>Selected records: {cursor.selectedRecordIds.join(', ')}</div>;
}
```

```javascript
import {useLoadable} from '@airtable/blocks/ui';

function LoadTwoQueryResults({queryResultA, queryResultB}) {
    // we have two query results. load them without suspense so they can be loaded together,
    // rather than one after the other
    useLoadable(queryResultA, {shouldSuspend: false});
    useLoadable(queryResultB, {shouldSuspend: false});

    // manually check whether loading is finished or not before continuing
    if (!queryResultA.isDataLoaded || !queryResultB.isDataLoaded) {
        return <div>Loading...</div>;
    }

    // now, we can use the data
    return <SomeFancyComponent />;
}
```

#### withHooks

A helper method for working with react hooks in class-based components. It takes a React component
and wraps it, injecting values from hooks as additional props. `withHooks` uses
[React.forwardRef][118] to make sure that you can use refs with your wrapped component in exactly
the same way you would if you weren't using withHooks.

##### Parameters

-   `Component` **React.Component** The React component you want to inject hooks into
-   `getAdditionalPropsToInject` **[Function][64]** a function that takes props and returns more
    props to be injected into the wrapped component

##### Examples

```javascript
import React from 'react';
import {useRecords, withHooks} from '@airtable/blocks/ui';

// RecordList takes a list of records and renders it
class RecordList extends React.Component {
    render() {
        const records = this.props.records.map(record => {
            return <li key={record.id}>{record.primaryCellValueAsString}</li>;
        });

        return <ul>{records}</ul>;
    }
}

// using withHooks, we wrap up RecordList. It takes a queryResult prop, and injects a records
// prop from useRecords
const WrappedRecordList = withHooks(RecordList, ({queryResult}) => {
    const records = useRecords(queryResult);
    return {
        records: records,
    };
});

// when we use WrappedRecordList, we only need to pass in queryResult:
<WrappedRecordList queryResult={someQueryResult} />;
```

```javascript
import React from 'react';
import {Record, QueryResult} from '@airtable/blocks/models';
import {withHooks, useRecords} from '@airtable/blocks/ui';
// with flow, things are a little more complex: we need to provide some type annotations to
// indicate which props are injected:

type RequiredProps = {|
    queryResult: QueryResult,
|};

type InjectedProps = {|
    records: Array<Record>,
|};

type RecordListProps = {|
    ...RequiredProps,
    ...InjectedProps,
|};

class RecordList extends React.Component<RecordListProps> {
    // implementation is the same as the example above
}

// you need to annotate the return type as React.AbstractComponent. This takes two type args:
//   - the Config (usually just props) of the resulting component
//   - the instance type (what you get out of a ref) of the resulting component
const WrappedRecordList: React.AbstractComponent<RequiredProps, RecordList> = withHooks(
    RecordList,
    ({queryResult}) => {
        const records = useRecords(queryResult);
        return {
            records,
        };
    },
);

// when using a ref to the component, you can't refer to it as WrappedRecordList like a normal
// class component. Instead, you need to wrap it in React.ElementRef:
const ref: React.ElementRef<typeof WrappedRecordList> = getTheRefSomehow();
```

Returns **React.Component** the wrapped React component

### expandRecord

#### expandRecord

Expands the given record in the Airtable UI.

##### Parameters

-   `record` **[Record][76]** the record to expand
-   `opts` **[object][65]?** An optional options object.
    -   `opts.records` **[Array][61]&lt;[Record][76]>?** If `records` is provided, the list will be
        used to page through records from the expanded record dialog.

##### Examples

```javascript
import {expandRecord} from '@airtable/blocks/ui';
expandRecord(record1, {
    records: [record1, record2, record3],
});
```

#### ExpandRecordOpts

Type: {records: [Array][61]&lt;[Record][76]>?}

##### Properties

-   `records` **[Array][61]&lt;[Record][76]>?**

### expandRecordList

Expands a list of records in the Airtable UI

#### Parameters

-   `records` **[Array][61]&lt;[Record][76]>** the records to expand. Duplicate records will be
    removed.
-   `opts` **{fields: [Array][61]&lt;[Field][73]>?}?** An optional options object.
    -   `opts.fields` optionally include an array of fields to control which fields are shown in the
        record cards. The primary field will always be shown. Duplicate fields will be removed.

#### Examples

```javascript
import {expandRecordList} from '@airtable/blocks/ui';
expandRecordList([record1, record2, record3]);

expandRecordList([record1, record2], {
    fields: [field1, field2],
});
```

### expandRecordPickerAsync

Expands a list of records in the Airtable UI, and prompts the user to pick one. The selected record
is returned to the block, and the modal is automatically closed.

If the user dismisses the modal, or another one is opened before this one has been closed, it will
return null.

#### Parameters

-   `records` **[Array][61]&lt;[Record][76]>** the records the user can pick from. Duplicate records
    will be removed.
-   `opts` **{fields: [Array][61]&lt;[Field][73]>?, shouldAllowCreatingRecord: [boolean][62]?}?** An
    optional options object.
    -   `opts.fields` optionally include an array of fields to control which fields are shown in the
        record cards. The primary field will always be shown. Duplicate fields will be removed.
    -   `opts.shouldAllowCreatingRecord` set to true to allow the user to create an empty new
        record.

#### Examples

```javascript
import {expandRecordPickerAsync} from '@airtable/blocks/ui';

const recordA = await expandRecordPickerAsync([record1, record2, record3]);
if (recordA !== null) {
    alert(recordA.primaryCellValueAsString);
} else {
    alert('no record picked');
}

const recordB = await expandRecordPickerAsync([record1, record2], {
    fields: [field1, field2],
});
```

Returns **[Promise][91]&lt;(record | null)>** a Promise that resolves to the record chosen by the
user or null

### AutocompletePopover

#### AutocompletePopover

**Extends React.Component**

##### Parameters

-   `props` **[AutocompletePopoverProps][119]**

#### AutocompletePopoverProps

Type: {children:
React$Element&lt;any>, items: [Array][61]&lt;[AutocompleteItem][120]>, renderItem: function (item: [AutocompleteItem][120], isFocused: [boolean][62]): React$Element&lt;any>?,
filterItems: function (query: [string][60], items: [Array][61]&lt;[AutocompleteItem][120]>):
[Array][61]&lt;[AutocompleteItem][120]>?, onSelect: function ([AutocompleteItem][120]): void,
placeholder: [string][60]?, focusOnOpen: [boolean][62]?, className: [string][60]?, style:
[Object][65]?, placementX: PopoverPlacementX?, placementY: PopoverPlacementY?, placementOffsetX:
[number][66]?, placementOffsetY: [number][66]?, fitInWindowMode: FitInWindowMode?, isOpen:
[boolean][62]?, onClose: function (opts: {wasFromEscape: [boolean][62]}): void?}

##### Properties

-   `children` **React\$Element&lt;any>**
-   `items` **[Array][61]&lt;[AutocompleteItem][120]>**
-   `renderItem` **function (item: [AutocompleteItem][120], isFocused: [boolean][62]):
    React\$Element&lt;any>?**
-   `filterItems` **function (query: [string][60], items: [Array][61]&lt;[AutocompleteItem][120]>):
    [Array][61]&lt;[AutocompleteItem][120]>?**
-   `onSelect` **function ([AutocompleteItem][120]): void**
-   `placeholder` **[string][60]?**
-   `focusOnOpen` **[boolean][62]?**
-   `className` **[string][60]?**
-   `style` **[Object][65]?**
-   `placementX` **PopoverPlacementX?**
-   `placementY` **PopoverPlacementY?**
-   `placementOffsetX` **[number][66]?**
-   `placementOffsetY` **[number][66]?**
-   `fitInWindowMode` **FitInWindowMode?**
-   `isOpen` **[boolean][62]?**
-   `onClose` **function (opts: {wasFromEscape: [boolean][62]}): void?**

#### AutocompleteItem

Type: {value: [string][60], label: [string][60], aliases: [Array][61]&lt;[string][60]>?}

##### Properties

-   `value` **[string][60]**
-   `label` **[string][60]**
-   `aliases` **[Array][61]&lt;[string][60]>?**

### Button

#### Button

**Extends React.Component**

Clickable button component.

##### Parameters

-   `props` **[ButtonProps][121]**

##### Examples

```javascript
import {Button} from '@airtable/blocks/ui';

const button = (
    <Button onClick={() => alert('Clicked!')} disabled={false} theme={Button.themes.BLUE}>
        Click here!
    </Button>
);
```

#### ButtonProps

Type: [object][65]

##### Properties

-   `theme` **(Button.themes.RED | Button.themes.GREEN | Button.themes.BLUE | Button.themes.YELLOW |
    Button.themes.WHITE | Button.themes.GRAY | Button.themes.DARK | Button.themes.TRANSPARENT)?**
    The color theme for the button.
-   `className` **[string][60]?** Extra `className`s to apply to the button, separated by spaces.
-   `style` **[object][65]?** Extra styles to apply to the button.
-   `onClick` **[function][64]?** Click event handler. Also handles Space and Enter keypress events.
-   `type` **[string][60]?** The type of the button.
-   `disabled` **[boolean][62]?** Indicates whether or not the user can interact with the button.
-   `tabIndex` **([number][66] \| [string][60])?** Indicates if the button can be focused and
    if/where it participates in sequential keyboard navigation.
-   `aria-label` **[string][60]?** The label for the button. Use this if the button lacks a visible
    text label.

### CellRenderer

#### CellRenderer

**Extends React.Component**

##### Parameters

-   `props` **[CellRendererProps][122]**

#### CellRendererProps

Type: {record: [Record][76]??, cellValue: any?, field: [Field][73], shouldWrap: [boolean][62]?,
className: [string][60]?, style: [Object][65]?}

##### Properties

-   `record` **[Record][76]??**
-   `cellValue` **any?**
-   `field` **[Field][73]**
-   `shouldWrap` **[boolean][62]?**
-   `className` **[string][60]?**
-   `style` **[Object][65]?**

### ChoiceToken

#### ChoiceToken

**Extends React.StatelessFunctionalComponent**

A component that shows a single choice in a small token, to be displayed inline or in a list of
choices.

##### Parameters

-   `props` **[ChoiceTokenProps][123]**

##### Examples

```javascript
import {UI} from '@airtable/blocks';

function ChoicesForSelectField({selectField}) {
    const choiceNodes = selectField.options.choices.map(choice => (
        <UI.ChoiceToken key={choice.id} choice={choice} />
    ));

    return (
        <React.Fragment>
            Here are all of your choices:
            {choiceNodes}
        </React.Fragment>
    );
}
```

#### ChoiceTokenProps

Type: [object][65]

##### Properties

-   `choice` **[object][65]** An object representing a select option. You should not create these
    objects from scratch, but should instead grab them from base data.
    -   `choice.id` **[string][60]** The ID of the select option.
    -   `choice.name` **[string][60]** The name of the select option.
    -   `choice.color` **[string][60]?** The color of the select option.
-   `className` **[string][60]?** Additional class names to apply to the collaborator token.

### CollaboratorToken

#### CollaboratorToken

**Extends React.StatelessFunctionalComponent**

A component that shows a single collaborator in a small token, to be displayed inline or in a list
of choices.

##### Parameters

-   `props` **[CollaboratorTokenProps][124]**

##### Examples

```javascript
import {CollaboratorToken, useSession} from '@airtable/blocks/ui';

function CurrentUserGreeter() {
    const session = useSession();
    return (
        <React.Fragment>
            Hello,
            <CollaboratorToken collaborator={session.currentUser} />!
        </React.Fragment>
    );
}
```

#### CollaboratorTokenProps

Type: [object][65]

##### Properties

-   `collaborator` **[object][65]** An object representing a collaborator. You should not create
    these objects from scratch, but should instead grab them from base data.
    -   `collaborator.id` **[string][60]?** The user ID of the collaborator.
    -   `collaborator.email` **[string][60]?** The email address of the collaborator.
    -   `collaborator.name` **[string][60]?** The name of the collaborator.
    -   `collaborator.profilePicUrl` **[string][60]?** The URL of the collaborator's profile
        picture.
-   `className` **[string][60]?** Additional class names to apply to the collaborator token.

### ColorPalette

#### ColorPalette

**Extends React.Component**

#### ColorPaletteProps

Type: {color: [string][60]?, allowedColors: [Array][61]&lt;[string][60]>, onChange: function
([string][60]): any?, squareSize: [number][66], squareMargin: [number][66], className: [string][60],
style: [Object][65], disabled: [boolean][62]?}

##### Properties

-   `color` **[string][60]?**
-   `allowedColors` **[Array][61]&lt;[string][60]>**
-   `onChange` **function ([string][60]): any?**
-   `squareSize` **[number][66]**
-   `squareMargin` **[number][66]**
-   `className` **[string][60]**
-   `style` **[Object][65]**
-   `disabled` **[boolean][62]?**

#### ColorPaletteSynced

**Extends React.Component**

#### ColorPaletteSyncedProps

Type: {globalConfigKey: [string][60], disabled: [boolean][62]?, onChange: function ([string][60]):
any?}

##### Properties

-   `globalConfigKey` **[string][60]**
-   `disabled` **[boolean][62]?**
-   `onChange` **function ([string][60]): any?**

### ConfirmationDialog

#### ConfirmationDialog

**Extends React.Component**

A styled modal dialog component that prompts the user to confirm or cancel an action. By default,
this component will focus the "Confirm" button on mount, so that pressing the Enter key will confirm
the action.

##### Parameters

-   `props` **[ConfirmationDialogProps][125]**

##### Examples

```javascript
import {Button, Dialog, ConfirmationDialog} from '@airtable/blocks/ui';
import React, {Fragment, useState} from 'react';

function Block() {
    const [isDialogOpen, setIsDialogOpen] = useState(false);
    return (
        <Fragment>
            <Button theme={Button.themes.BLUE} onClick={() => setIsDialogOpen(true)}>
                Open dialog
            </Button>
            {isDialogOpen && (
                <ConfirmationDialog
                    title="Are you sure?"
                    body="This action can't be undone."
                    onConfirm={() => {
                        alert('Confirmed.');
                        setIsDialogOpen(false);
                    }}
                    onCancel={() => setIsDialogOpen(false)}
                />
            )}
        </Fragment>
    );
}
```

#### ConfirmationDialogProps

Type: [Object][65]

##### Properties

-   `title` **[string][60]** The title of the dialog.
-   `body` **React.Node?** The body of the dialog.
-   `cancelButtonText` **[string][60]?** The label for the cancel button.
-   `confirmButtonText` **[string][60]?** The label for the confirm button.
-   `isConfirmActionDangerous` **[boolean][62]?** Whether the action is dangerous (potentially
    destructive or not easily reversible).
-   `className` **[string][60]?** Extra `className`s to apply to the dialog element, separated by
    spaces.
-   `style` **[Object][65]?** Extra styles to apply to the dialog element.
-   `backgroundClassName` **[string][60]?** Extra `className`s to apply to the lightbox element,
    separated by spaces.
-   `backgroundStyle` **[Object][65]?** Extra styles to apply to the lightbox element.
-   `onCancel` **[function][64]** Cancel button event handler. Handles click events and Space and
    Enter keypress events.
-   `onConfirm` **[function][64]** Confirm button event handler. Handles click events and Space and
    Enter keypress events.

### Dialog

#### Dialog

**Extends React.Component**

A styled modal dialog component.

##### Parameters

-   `props` **[DialogProps][126]**

##### Examples

```javascript
import {Button, Dialog} from '@airtable/blocks/ui';
import React, {Fragment, useState} from 'react';

function Block() {
    const [isDialogOpen, setIsDialogOpen] = useState(false);
    return (
        <Fragment>
            <Button theme={Button.themes.BLUE} onClick={() => setIsDialogOpen(true)}>
                Open dialog
            </Button>
            {isDialogOpen && (
                <Dialog onClose={() => setIsDialogOpen(false)}>
                    <Fragment>
                        <Dialog.CloseButton />
                        <h1
                            style={{
                                marginBottom: 8,
                                fontSize: 20,
                                fontWeight: 500,
                            }}
                        >
                            Dialog
                        </h1>
                        <p>This is the dialog content.</p>
                    </Fragment>
                </Dialog>
            )}
        </Fragment>
    );
}
```

#### DialogProps

Type: [object][65]

##### Properties

-   `onClose` **[function][64]** Callback function to fire when the dialog is closed.
-   `className` **[string][60]?** Extra `className`s to apply to the dialog element, separated by
    spaces.
-   `style` **[Object][65]?** Extra styles to apply to the dialog element.
-   `backgroundClassName` **[string][60]?** Extra `className`s to apply to the lightbox element,
    separated by spaces.
-   `backgroundStyle` **[Object][65]?** Extra styles to apply to the lightbox element.

#### Dialog.CloseButton

**Extends React.Component**

A button that closes [Dialog][39].

##### Parameters

-   `props` **[DialogCloseButtonProps][127]**

#### DialogCloseButtonProps

Type: [object][65]

##### Properties

-   `className` **[string][60]?** `className`s to apply to the close button, separated by spaces.
-   `style` **[object][65]?** Styles to apply to the dialog element.
-   `tabIndex` **([number][66] \| [string][60])?** Indicates if the button can be focused and
    if/where it participates in sequential keyboard navigation.

### FieldPicker

#### FieldPicker

**Extends React.Component**

Dropdown menu component for selecting fields.

##### Parameters

-   `props` **[FieldPickerProps][128]**

##### Examples

```javascript
import {TablePicker, FieldPicker, useBase} from '@airtable/blocks/ui';
import {fieldTypes} from '@airtable/blocks/models';
import React, {Fragment, useState} from 'react';

function Block() {
    useBase();
    const [table, setTable] = useState(null);
    const [field, setField] = useState(null);

    const summaryText = field
        ? `The field type for ${field.name} is ${field.type}.`
        : 'No field selected.';
    return (
        <Fragment>
            <p style={{marginBottom: 16}}>{summaryText}</p>
            <label style={{display: 'block', marginBottom: 16}}>
                <div style={{marginBottom: 8, fontWeight: 500}}>Table</div>
                <TablePicker
                    table={table}
                    onChange={newTable => {
                        setTable(newTable);
                        setField(null);
                    }}
                    shouldAllowPickingNone={true}
                />
            </label>
            {table && (
                <label>
                    <div style={{marginBottom: 8, fontWeight: 500}}>Field</div>
                    <FieldPicker
                        table={table}
                        field={field}
                        onChange={newField => setField(newField)}
                        allowedTypes={[
                            fieldTypes.SINGLE_LINE_TEXT,
                            fieldTypes.MULTILINE_TEXT,
                            fieldTypes.EMAIL,
                            fieldTypes.URL,
                            fieldTypes.PHONE_NUMBER,
                        ]}
                        shouldAllowPickingNone={true}
                    />
                </label>
            )}
        </Fragment>
    );
}
```

#### FieldPickerProps

Type: [object][65]

##### Properties

-   `table` **[Table][78]?** The parent table model to select fields from. If `null` or `undefined`,
    the picker won't render.
-   `field` **[Field][73]?** The selected field model.
-   `onChange` **[function][64]?** A function to be called when the selected field changes.
-   `disabled` **[boolean][62]?** If set to `true`, the user cannot interact with the picker.
-   `allowedTypes` **[Array][61]&lt;FieldType>?** An array indicating which field types can be
    selected.
-   `shouldAllowPickingNone` **[boolean][62]?** If set to `true`, the user can unset the selected
    field.
-   `placeholder` **[string][60]?** The placeholder text when no field is selected.
-   `id` **[string][60]?** The ID of the picker element.
-   `className` **[string][60]?** Additional class names to apply to the picker.
-   `style` **[object][65]?** Additional styles to apply to the picker.
-   `tabIndex` **([number][66] \| [string][60])?** Indicates if the picker can be focused and
    if/where it participates in sequential keyboard navigation.
-   `aria-labelledby` **[string][60]?** A space separated list of label element IDs.
-   `aria-describedby` **[string][60]?** A space separated list of description element IDs.

#### FieldPickerSynced

**Extends React.Component**

Dropdown menu component for selecting fields, synced with [GlobalConfig][3].

##### Parameters

-   `props` **[FieldPickerSyncedProps][129]**

##### Examples

```javascript
import {TablePickerSynced, FieldPickerSynced, useBase, useWatchable} from '@airtable/blocks/ui';
import {fieldTypes} from '@airtable/blocks/models';
import {globalConfig} from '@airtable/blocks';
import React, {Fragment} from 'react';

function Block() {
    const base = useBase();
    const tableId = globalConfig.get('tableId');
    const table = base.getTableByIdIfExists(tableId);
    const fieldId = globalConfig.get('fieldId');
    const field = table.getFieldByIdIfExists(fieldId);
    useWatchable(globalConfig, ['tableId', 'fieldId']);

    const summaryText = field
        ? `The field type for ${field.name} is ${field.type}.`
        : 'No field selected.';
    return (
        <Fragment>
            <p style={{marginBottom: 16}}>{summaryText}</p>
            <label style={{display: 'block', marginBottom: 16}}>
                <div style={{marginBottom: 8, fontWeight: 500}}>Table</div>
                <TablePickerSynced globalConfigKey="tableId" shouldAllowPickingNone={true} />
            </label>
            {table && (
                <label>
                    <div style={{marginBottom: 8, fontWeight: 500}}>Field</div>
                    <FieldPickerSynced
                        table={table}
                        globalConfigKey="fieldId"
                        allowedTypes={[
                            fieldTypes.SINGLE_LINE_TEXT,
                            fieldTypes.MULTILINE_TEXT,
                            fieldTypes.EMAIL,
                            fieldTypes.URL,
                            fieldTypes.PHONE_NUMBER,
                        ]}
                        shouldAllowPickingNone={true}
                    />
                </label>
            )}
        </Fragment>
    );
}
```

#### FieldPickerSyncedProps

Type: [object][65]

##### Properties

-   `table` **[Table][78]?** The parent table model to select fields from. If `null` or `undefined`,
    the picker won't render.
-   `globalConfigKey` **[GlobalConfigKey][130]** A string key or array key path in
    [GlobalConfig][3]. The selected field will always reflect the field id stored in `globalConfig`
    for this key. Selecting a new field will update `globalConfig`.
-   `onChange` **[function][64]?** A function to be called when the selected field changes. This
    should only be used for side effects.
-   `disabled` **[boolean][62]?** If set to `true`, the user cannot interact with the picker.
-   `allowedTypes` **[Array][61]&lt;FieldType>?** An array indicating which field types can be
    selected.
-   `shouldAllowPickingNone` **[boolean][62]?** If set to `true`, the user can unset the selected
    field.
-   `placeholder` **[string][60]?** The placeholder text when no field is selected.
-   `id` **[string][60]?** The ID of the picker element.
-   `className` **[string][60]?** Additional class names to apply to the picker.
-   `style` **[object][65]?** Additional styles to apply to the picker.
-   `tabIndex` **([number][66] \| [string][60])?** Indicates if the picker can be focused and
    if/where it participates in sequential keyboard navigation.
-   `aria-labelledby` **[string][60]?** A space separated list of label element IDs.
-   `aria-describedby` **[string][60]?** A space separated list of description element IDs.

### Icon

#### Icon

**Extends React.StatelessFunctionalComponent**

A vector icon from the Airtable icon set.

##### Parameters

-   `props` **[IconProps][131]**

##### Examples

```javascript
import {Button, Icon} from '@airtable/blocks/ui';

const LikeButton = (
    <Button theme={Button.themes.RED} onClick={() => alert('Liked!')}>
        <Icon name="heart" fillColor="#fff" style={{marginRight: 8}} />
        Like
    </Button>
);
```

#### IconProps

Type: [object][65]

##### Properties

-   `name` **[string][60]** The name of the icon. For a comprehensive list, refer to the "Icon"
    section of the [styleguide][132].
-   `size` **[number][66]?** The width/height of the icon.
-   `fillColor` **[string][60]?** The color of the icon.
-   `className` **[string][60]?** Additional class names to apply to the icon.
-   `style` **[object][65]?** Additional styles to apply to the icon.
-   `pathClassName` **[string][60]?** Additional class names to apply to the icon path.
-   `pathStyle` **[object][65]?** Additional styles to apply to the icon path.

#### FieldIcon

**Extends React.StatelessFunctionalComponent**

A vector icon for a field's type.

##### Parameters

-   `props` **[FieldIconProps][133]**

##### Examples

```javascript
import {FieldIcon, useBase} from '@airtable/blocks/ui';

const base = useBase();
const table = base.tables[0];
const {primaryField} = table;

const FieldToken = (
    <div
        style={{
            display: 'inline-flex',
            alignItems: 'center',
            padding: 8,
            fontWeight: 500,
            backgroundColor: '#eee',
            borderRadius: 3,
        }}
    >
        <FieldIcon field={primaryField} style={{marginRight: 8}} />
        {primaryField.name}
    </div>
);
```

#### FieldIconProps

Type: [object][65]

##### Properties

-   `field` **[Field][73]** The field model to display an icon for.
-   `size` **[number][66]?** The width/height of the icon.
-   `fillColor` **[string][60]?** The color of the icon.
-   `className` **[string][60]?** Additional class names to apply to the icon.
-   `style` **[object][65]?** Additional styles to apply to the icon.
-   `pathClassName` **[string][60]?** Additional class names to apply to the icon path.
-   `pathStyle` **[object][65]?** Additional styles to apply to the icon path.

### Input

#### Input

**Extends React.Component**

An input component. A wrapper around `<input>` that fits in with Airtable's user interface.

##### Parameters

-   `props` **[InputProps][134]**

##### Examples

```javascript
import {Input} from '@airtable/blocks/ui';
import React, {Fragment, useState} from 'react';

function HelloSomeone() {
    const [value, setValue] = useState('world');

    return (
        <Fragment>
            <div>Hello, {value}!</div>

            <Input
                value={value}
                onChange={event => setValue(event.target.value)}
                placeholder="world"
            />
        </Fragment>
    );
}
```

#### InputProps

Type: [object][65]

##### Properties

-   `type` **[string][60]?** The `type` for the input. Defaults to `text`.
-   `placeholder` **[string][60]?** The placeholder for the input.
-   `value` **[string][60]?** The input's current value. Required if `onChange` is set.
-   `onChange` **[function][64]?** A function to be called when the input changes. Required if
    `value` is set.
-   `style` **[object][65]?** Additional styles to apply to the input.
-   `className` **[string][60]?** Additional class names to apply to the input, separated by spaces.
-   `disabled` **[boolean][62]?** If set to `true`, the input will be disabled.
-   `required` **[boolean][62]?** If set to `true`, the input will be required.
-   `spellCheck` **[boolean][62]?** If set to `true`, the `spellcheck` property will be set on the
    input.
-   `tabIndex` **([number][66] \| [string][60])?** The `tabindex` for the input.

#### InputSynced

**Extends React.Component**

A wrapper around the `UI.Input` component that syncs with global config.

##### Parameters

-   `props` **[InputSyncedProps][135]**

##### Examples

```javascript
import {UI} from '@airtable/blocks/ui';
import {globalConfig} from '@airtable/blocks';
import React from 'react';

function ApiKeyInput() {
    const canEditApiKey = globalConfig.canSet('apiKey');
    return <UI.InputSynced globalConfigKey="apiKey" disabled={!canEditApiKey} />;
}
```

#### InputSyncedProps

Type: [object][65]

##### Properties

-   `type` **[string][60]?** The `type` for the input. Defaults to `text`.
-   `globalConfigKey` **([string][60] \| [Array][61]&lt;[string][60]>)** The key, or path to a key,
    in global config.
-   `placeholder` **[string][60]?** The placeholder for the input.
-   `onChange` **[function][64]?** A function to be called when the input changes. Note that this
    component will sync to global config, so you won't always need to set this.
-   `style` **[object][65]?** Additional styles to apply to the input.
-   `className` **[string][60]?** Additional class names to apply to the input, separated by spaces.
-   `disabled` **[boolean][62]?** If set to `true`, the input will be disabled.
-   `spellCheck` **[boolean][62]?** If set to `true`, the `spellcheck` property will be set on the
    input.

### Link

#### Link

**Extends React.StatelessFunctionalComponent**

A wrapper around the `<a>` tag that offers a few security benefits:

-   Limited XSS protection. If the `href` starts with `javascript:` or `data:`, `http://` will be
    prepended.
-   There is [reverse tabnabbing prevention][136]. If `target` is set, the `rel` attribute will be
    set to `noopener noreferrer`.

Developers should use `Link` instead of `a` when possible.

##### Parameters

-   `props` **[LinkProps][137]**

##### Examples

```javascript
import {UI} from '@airtable/blocks/ui';

function MyLinkComponent() {
    return <UI.Link href="https://example.com">Check out my homepage!</UI.Link>;
}
```

#### LinkProps

Type: [object][65]

##### Properties

-   `href` **[string][60]** The target URL or URL fragment for the link.
-   `target` **[string][60]?** Specifies where to display the linked URL.
-   `tabIndex` **([number][66] \| [string][60])?** Indicates if the link can be focused and if/where
    it participates in sequential keyboard navigation.
-   `className` **[string][60]?** Additional class names to apply to the link.
-   `style` **[object][65]?** Additional styles to apply to the link.

### Loader

#### Loader

**Extends React.StatelessFunctionalComponent**

A loading spinner component.

##### Parameters

-   `props` **[LoaderProps][138]**

##### Examples

```javascript
import {Loader} from '@airtable/blocks/ui';

function MyDataComponent() {
    if (myDataHasLoaded) {
        return <div>Here's your data!</div>;
    } else {
        return <Loader />;
    }
}
```

#### LoaderProps

Type: [object][65]

##### Properties

-   `fillColor` **[string][60]?** The color of the loading spinner.
-   `scale` **[number][66]?** A scalar for the loader. Increasing the scale increases the size of
    the loader.

### Popover

#### Popover

**Extends React.Component**

-   **See: [Tooltip][52]**

A popover component, which is used to "float" some content above some other content.

##### Parameters

-   `props` **[PopoverProps][139]**

#### PopoverProps

Type: [object][65]

##### Properties

-   `children` **React\$Element&lt;any>** Child components to render.
-   `renderContent` **[function][64]** A function that returns the contents of the popover as React
    elements.
-   `placementX` **(Popover.placements.LEFT | Popover.placements.CENTER |
    Popover.placements.RIGHT)?** The horizontal placement of the popover.
-   `placementY` **(Popover.placements.TOP | Popover.placements.CENTER |
    Popover.placements.BOTTOM)?** The vertical placement of the popover.
-   `placementOffsetX` **[number][66]?** The horizontal offset, in pixels, of the popover. If
    `placementX` is set to `Popover.placements.LEFT`, a higher number will move the popover to the
    left. If `placementX` is set to `Popover.placements.RIGHT`, a higher number moves the popover to
    the right. If `placementX` is set to `Popover.placements.CENTER`, this value has no effect.
-   `placementOffsetY` **[number][66]?** The vertical offset, in pixels, of the popover. If
    `placementY` is set to `Popover.placements.TOP`, a higher number will move the popover upward.
    If `placementY` is set to `Popover.placements.BOTTOM`, a higher number moves the popover
    downard. If `placementY` is set to `Popover.placements.CENTER`, this value has no effect.
-   `fitInWindowMode` **(Popover.fitInWindowModes.FLIP | Popover.fitInWindowModes.NUDGE |
    Popover.fitInWindowModes.NONE)?** Dictates the behavior when the "normal" placement of the
    popover would be outside of the viewport. If `NONE`, this has no effect, and the popover may be
    placed off-screen. If `FLIP`, we'll switch the placement to the other side (for example, moving
    the popover from the left to the right). If `NUDGE`, the popover will be "nudged" just enough to
    fit on screen.
-   `onClose` **[function][64]?** A function that will be called when the popover closes.
-   `isOpen` **[boolean][62]** A boolean that dictates whether the popover is open.
-   `backgroundClassName` **[string][60]?** Extra class names for the background of the popover,
    separated by spaces.
-   `backgroundStyle` **[object][65]?** Extra styles for the background of the popover.

#### Popover.fitInWindowModes

An enum describing the fit-in-window mode. One of `Popover.fitInWindowModes.NONE`,
`Popover.fitInWindowModes.FLIP`, `Popover.fitInWindowModes.NUDGE`.

#### Popover.placements

An enum describing popover placements. One of `Popover.placements.TOP`, `Popover.placements.CENTER`,
`Popover.placements.BOTTOM`, `Popover.placements.LEFT`, `Popover.placements.RIGHT`.

### ProgressBar

#### ProgressBar

A progress bar.

##### Parameters

-   `props` **[ProgressBarProps][140]**

##### Examples

```javascript
import {UI} from '@airtable/blocks/ui';

function MyComponent() {
    return <ProgressBar progress={0.6} barColor="#ff9900" />;
}
```

#### ProgressBarProps

Type: [object][65]

##### Properties

-   `progress` **[number][66]** A number between 0 and 1. 0 is 0% complete, 0.5 is 50% complete, 1
    is 100% complete. If you include a number outside of the range, the value will be clamped to be
    inside of the range.
-   `barColor` **[string][60]?** A CSS color, such as `#ff9900`.
-   `backgroundColor` **[string][60]?** A CSS color, such as `#ff9900`.
-   `height` **[number][66]?** A height, in pixels.
-   `className` **[string][60]?** Extra `className`s to apply to the element, separated by spaces.
-   `style` **[object][65]?** Extra styles to apply to the progress bar.

### RecordCard

#### RecordCard

**Extends React.Component**

##### Parameters

-   `props` **[RecordCardProps][141]**

#### RecordCardProps

Type: {record: ([Record][76] | RecordDef), fields: [Array][61]&lt;[Field][73]>?, view: [View][74]?,
attachmentCoverField: [Field][73]?, width: [number][66]?, height: [number][66]?, onClick:
[Function][64]?, getExpandRecordOptions: function ([Record][76]): [ExpandRecordOpts][142]?,
onMouseEnter: any?, onMouseLeave: any?, className: [string][60]?, style: [Object][65]?,
viewMetadata: ([ViewMetadataQueryResult][99] | null)}

##### Properties

-   `record` **([Record][76] | RecordDef)**
-   `fields` **[Array][61]&lt;[Field][73]>?**
-   `view` **[View][74]?**
-   `attachmentCoverField` **[Field][73]?**
-   `width` **[number][66]?**
-   `height` **[number][66]?**
-   `onClick` **[Function][64]?**
-   `getExpandRecordOptions` **function ([Record][76]): [ExpandRecordOpts][142]?**
-   `onMouseEnter` **any?**
-   `onMouseLeave` **any?**
-   `className` **[string][60]?**
-   `style` **[Object][65]?**
-   `viewMetadata` **([ViewMetadataQueryResult][99] | null)**

### Select

#### Select

**Extends React.Component**

Dropdown menu component. A wrapper around `<select>` that fits in with Airtable's user interface.

##### Parameters

-   `props` **[SelectProps][143]**

##### Examples

```javascript
import {Select} from '@airtable/blocks/ui';
import React, {useState} from 'react';

function ColorPicker() {
    const [value, setValue] = useState(null);
    return (
        <label>
            <div style={{marginBottom: 8, fontWeight: 500}}>Color</div>
            <Select
                onChange={newValue => setValue(newValue)}
                value={value}
                options={[
                    {value: null, label: 'Pick a color...', disabled: true},
                    {value: 'red', label: 'red'},
                    {value: 'green', label: 'green'},
                    {value: 'blue', label: 'blue'},
                ]}
            />
        </label>
    );
}
```

#### SelectProps

Type: [object][65]

##### Properties

-   `onChange` **[function][64]?** A function to be called when the selected option changes.
-   `value` **([string][60] \| [number][66] \| [boolean][62] | null)?** The value of the selected
    option.
-   `options` **[Array][61]&lt;[SelectOption][144]>** The list of select options.
-   `disabled` **[boolean][62]?** If set to `true`, the user cannot interact with the button.
-   `id` **[string][60]?** The ID of the select element.
-   `className` **[string][60]?** Additional class names to apply to the select.
-   `style` **[object][65]?** Additional styles to apply to the select.
-   `tabIndex` **([number][66] \| [string][60])?** Indicates if the select can be focused and
    if/where it participates in sequential keyboard navigation.
-   `aria-labelledby` **[string][60]?** A space separated list of label element IDs.
-   `aria-describedby` **[string][60]?** A space separated list of description element IDs.

#### SelectOption

Type: [object][65]

##### Properties

-   `value` **([string][60] \| [number][66] \| [boolean][62] | null)** The value for the select
    option.
-   `label` **React.Node** The label for the select option.
-   `disabled` **[boolean][62]?** If set to `true`, this option will not be selectable.

#### SelectSynced

**Extends React.Component**

Dropdown menu component synced with [GlobalConfig][3]. A wrapper around `<select>` that fits in with
Airtable's user interface.

##### Parameters

-   `props` **[SelectSyncedProps][145]**

##### Examples

```javascript
import {SelectSynced} from '@airtable/blocks/ui';
import React from 'react';

function ColorPickerSynced() {
    return (
        <label>
            <div style={{marginBottom: 8, fontWeight: 500}}>Color</div>
            <SelectSynced
                globalConfigKey="color"
                options={[
                    {value: null, label: 'Pick a color...', disabled: true},
                    {value: 'red', label: 'red'},
                    {value: 'green', label: 'green'},
                    {value: 'blue', label: 'blue'},
                ]}
            />
        </label>
    );
}
```

#### SelectSyncedProps

Type: [object][65]

##### Properties

-   `globalConfigKey` **[GlobalConfigKey][130]** A string key or array key path in
    [GlobalConfig][3]. The selected option will always reflect the value stored in `globalConfig`
    for this key. Selecting a new option will update `globalConfig`.
-   `onChange` **[function][64]?** A function to be called when the selected option changes. This
    should only be used for side effects.
-   `options` **[Array][61]&lt;[SelectOption][144]>** The list of select options.
-   `disabled` **[boolean][62]?** If set to `true`, the user cannot interact with the select.
-   `id` **[string][60]?** The ID of the select element.
-   `className` **[string][60]?** Additional class names to apply to the select.
-   `style` **[object][65]?** Additional styles to apply to the select.
-   `tabIndex` **([number][66] \| [string][60])?** Indicates if the select can be focused and
    if/where it participates in sequential keyboard navigation.
-   `aria-labelledby` **[string][60]?** A space separated list of label element IDs.
-   `aria-describedby` **[string][60]?** A space separated list of description element IDs.

### SelectButtons

#### SelectButtons

**Extends React.Component**

#### SelectButtonsProps

Type: SelectAndSelectButtonsProps

#### SelectButtonsSynced

**Extends React.Component**

#### SelectButtonsSyncedProps

Type: SelectAndSelectButtonsSyncedProps

### TablePicker

#### TablePicker

**Extends React.Component**

Dropdown menu component for selecting tables.

##### Parameters

-   `props` **[TablePickerProps][146]**

##### Examples

```javascript
import {TablePicker, useBase, useRecords} from '@airtable/blocks/ui';
import React, {Fragment, useState} from 'react';

function Block() {
    useBase();
    const [table, setTable] = useState(null);
    const queryResult = table ? table.selectRecords() : null;
    const records = useRecords(queryResult);

    const summaryText = table
        ? `${table.name} has ${records.length} record(s).`
        : 'No table selected.';
    return (
        <Fragment>
            <p style={{marginBottom: 16}}>{summaryText}</p>
            <label>
                <div style={{marginBottom: 8, fontWeight: 500}}>Table</div>
                <TablePicker
                    table={table}
                    onChange={newTable => setTable(newTable)}
                    shouldAllowPickingNone={true}
                />
            </label>
        </Fragment>
    );
}
```

#### TablePickerProps

Type: [object][65]

##### Properties

-   `table` **[Table][78]?** The selected table model.
-   `onChange` **[function][64]?** A function to be called when the selected table changes.
-   `disabled` **[boolean][62]?** If set to `true`, the user cannot interact with the picker.
-   `shouldAllowPickingNone` **[boolean][62]?** If set to `true`, the user can unset the selected
    table.
-   `placeholder` **[string][60]?** The placeholder text when no table is selected.
-   `id` **[string][60]?** The ID of the picker element.
-   `className` **[string][60]?** Additional class names to apply to the picker.
-   `style` **[object][65]?** Additional styles to apply to the picker.
-   `tabIndex` **([number][66] \| [string][60])?** Indicates if the picker can be focused and
    if/where it participates in sequential keyboard navigation.
-   `aria-labelledby` **[string][60]?** A space separated list of label element IDs.
-   `aria-describedby` **[string][60]?** A space separated list of description element IDs.

#### TablePickerSynced

**Extends React.Component**

Dropdown menu component for selecting tables, synced with [GlobalConfig][3].

##### Parameters

-   `props` **[TablePickerSyncedProps][147]**

##### Examples

```javascript
import {TablePickerSynced, useBase, useRecords, useWatchable} from '@airtable/blocks/ui';
import {globalConfig} from '@airtable/blocks';
import React, {Fragment} from 'react';

function Block() {
    const base = useBase();
    const tableId = globalConfig.get('tableId');
    const table = base.getTableByIdIfExists(tableId);
    const queryResult = table ? table.selectRecords() : null;
    const records = useRecords(queryResult);
    useWatchable(globalConfig, ['tableId']);

    const summaryText = table
        ? `${table.name} has ${records.length} record(s).`
        : 'No table selected.';
    return (
        <Fragment>
            <p style={{marginBottom: 16}}>{summaryText}</p>
            <label>
                <div style={{marginBottom: 8, fontWeight: 500}}>Table</div>
                <TablePickerSynced globalConfigKey="tableId" shouldAllowPickingNone={true} />
            </label>
        </Fragment>
    );
}
```

#### TablePickerSyncedProps

Type: [object][65]

##### Properties

-   `globalConfigKey` **[GlobalConfigKey][130]** A string key or array key path in
    [GlobalConfig][3]. The selected table will always reflect the table id stored in `globalConfig`
    for this key. Selecting a new table will update `globalConfig`.
-   `onChange` **[function][64]?** A function to be called when the selected table changes. This
    should only be used for side effects.
-   `disabled` **[boolean][62]?** If set to `true`, the user cannot interact with the picker.
-   `shouldAllowPickingNone` **[boolean][62]?** If set to `true`, the user can unset the selected
    table.
-   `placeholder` **[string][60]?** The placeholder text when no table is selected.
-   `id` **[string][60]?** The ID of the picker element.
-   `className` **[string][60]?** Additional class names to apply to the picker.
-   `style` **[object][65]?** Additional styles to apply to the picker.
-   `tabIndex` **([number][66] \| [string][60])?** Indicates if the picker can be focused and
    if/where it participates in sequential keyboard navigation.
-   `aria-labelledby` **[string][60]?** A space separated list of label element IDs.
-   `aria-describedby` **[string][60]?** A space separated list of description element IDs.

### Toggle

#### Toggle

**Extends React.Component**

A toggleable switch for controlling boolean values. Functionally analogous to a checkbox.

##### Parameters

-   `props` **[ToggleProps][148]**

##### Examples

```javascript
import {Toggle} from '@airtable/blocks/ui';
import React, {useState} from 'react';

function Block() {
    const [isEnabled, setIsEnabled] = useState(false);
    return <Toggle value={isEnabled} onChange={setIsEnabled} label={isEnabled ? 'On' : 'Off'} />;
}
```

#### ToggleProps

Type: [object][65]

##### Properties

-   `value` **[boolean][62]** If set to `true`, the switch will be toggled on.
-   `onChange` **[function][64]?** A function to be called when the switch is toggled.
-   `disabled` **[boolean][62]?** If set to `true`, the user cannot interact with the switch.
-   `label` **React.Node?** The label node for the switch.
-   `theme` **(Toggle.themes.GREEN | Toggle.themes.BLUE | Toggle.themes.RED | Toggle.themes.YELLOW |
    Toggle.themes.GRAY)?** The color theme for the switch.
-   `id` **[string][60]?** The ID of the switch element.
-   `className` **[string][60]?** Additional class names to apply to the switch.
-   `style` **[object][65]?** Additional styles to apply to the switch.
-   `tabIndex` **([number][66] \| [string][60])?** Indicates if the switch can be focused and
    if/where it participates in sequential keyboard navigation.
-   `aria-label` **[string][60]?** The label for the switch. Use this if the switch lacks a visible
    text label.
-   `aria-labelledby` **[string][60]?** A space separated list of label element IDs.
-   `aria-describedby` **[string][60]?** A space separated list of description element IDs.

#### ToggleSynced

**Extends React.Component**

A toggleable switch for controlling boolean values, synced with [GlobalConfig][3]. Functionally
analogous to a checkbox.

##### Parameters

-   `props` **[ToggleSyncedProps][149]**

##### Examples

```javascript
import {ToggleSynced, useWatchable} from '@airtable/blocks/ui';
import {globalConfig} from '@airtable/blocks';
import React from 'react';

function Block() {
    useWatchable(globalConfig, ['isEnabled']);
    return (
        <Toggle globalConfigKey="isEnabled" label={globalConfig.get('isEnabled') ? 'On' : 'Off'} />
    );
}
```

#### ToggleSyncedProps

Type: [object][65]

##### Properties

-   `globalConfigKey` **[GlobalConfigKey][130]** A string key or array key path in
    [GlobalConfig][3]. The switch option will always reflect the boolean value stored in
    `globalConfig` for this key. Toggling the switch will update `globalConfig`.
-   `onChange` **[function][64]?** A function to be called when the switch is toggled. This should
    only be used for side effects.
-   `label` **React.Node?** The label node for the switch.
-   `disabled` **[boolean][62]?** If set to `true`, the user cannot interact with the switch.
-   `theme` **(Toggle.themes.GREEN | Toggle.themes.BLUE | Toggle.themes.RED | Toggle.themes.YELLOW |
    Toggle.themes.GRAY)?** The color theme for the switch.
-   `id` **[string][60]?** The ID of the switch element.
-   `className` **[string][60]?** Additional class names to apply to the switch.
-   `style` **[object][65]?** Additional styles to apply to the switch.
-   `tabIndex` **([number][66] \| [string][60])?** Indicates if the switch can be focused and
    if/where it participates in sequential keyboard navigation.
-   `aria-label` **[string][60]?** The label for the switch. Use this if the switch lacks a visible
    text label.
-   `aria-labelledby` **[string][60]?** A space separated list of label element IDs.
-   `aria-describedby` **[string][60]?** A space separated list of description element IDs.

### Tooltip

#### Tooltip

**Extends React.Component**

A component that shows a tooltip. Wraps its children.

##### Parameters

-   `props` **[TooltipProps][150]**

##### Examples

```javascript
import {UI} from '@airtable/blocks';

function MyComponent() {
    return (
        <UI.Tooltip
            content="Clicking this button will be a lot of fun!"
            placementX={UI.Tooltip.placements.CENTER}
            placementY={UI.Tooltip.placements.TOP}
        >
            <UI.Button onClick={() => alert('Clicked!')}>Click here!</UI.Button>
        </UI.Tooltip>
    );
}
```

#### TooltipProps

Type: [object][65]

##### Properties

-   `children` **React\$Element&lt;any>** Child components to render.
-   `content` **([string][60] \| [function][64])** A string representing the contents.
    Alternatively, you can include a function that returns a React node to place into the tooltip,
    which is useful for things like italicization in the tooltip.
-   `placementX` **(UI.Tooltip.placements.LEFT | UI.Tooltip.placements.CENTER |
    UI.Tooltip.placements.RIGHT)?** The horizontal placement of the tooltip.
-   `placementY` **(UI.Tooltip.placements.TOP | UI.Tooltip.placements.CENTER |
    UI.Tooltip.placements.BOTTOM)?** The vertical placement of the tooltip.
-   `placementOffsetX` **[number][66]?** The horizontal offset, in pixels, of the tooltip. If
    `placementX` is set to `UI.Tooltip.placements.LEFT`, a higher number will move the tooltip to
    the left. If `placementX` is set to `UI.Tooltip.placements.RIGHT`, a higher number moves the
    tooltip to the right. If `placementX` is set to `UI.Tooltip.placements.CENTER`, this value has
    no effect.
-   `placementOffsetY` **[number][66]?** The vertical offset, in pixels, of the tooltip. If
    `placementY` is set to `UI.Tooltip.placements.TOP`, a higher number will move the tooltip
    upward. If `placementY` is set to `UI.Tooltip.placements.BOTTOM`, a higher number moves the
    tooltip downard. If `placementY` is set to `UI.Tooltip.placements.CENTER`, this value has no
    effect.
-   `fitInWindowMode` **(UI.Tooltip.fitInWindowModes.FLIP | UI.Tooltip.fitInWindowModes.NUDGE |
    UI.Tooltip.fitInWindowModes.NONE)?** Dictates the behavior when the "normal" placement of the
    tooltip would be outside of the viewport. If `NONE`, this has no effect, and the tooltip may be
    placed off-screen. If `FLIP`, we'll switch the placement to the other side (for example, moving
    the tooltip from the left to the right). If `NUDGE`, the tooltip will be "nudged" just enough to
    fit on screen.
-   `shouldHideTooltipOnClick` **[boolean][62]?** Should the tooltip be hidden when clicked?
-   `disabled` **[boolean][62]?** If set to `true`, this tooltip will not be shown. Useful when
    trying to disable the tooltip dynamically.
-   `className` **[string][60]?** Additional class names to attach to the tooltip, separated by
    spaces.
-   `style` **[object][65]?** Additional styles names to attach to the tooltip.

### ViewPicker

#### ViewPicker

**Extends React.Component**

Dropdown menu component for selecting views.

##### Parameters

-   `props` **[ViewPickerProps][151]**

##### Examples

```javascript
import {TablePicker, ViewPicker, useBase, useRecords} from '@airtable/blocks/ui';
import {viewTypes} from '@airtable/blocks/models';
import React, {Fragment, useState} from 'react';

function Block() {
    useBase();
    const [table, setTable] = useState(null);
    const [view, setView] = useState(null);
    const queryResult = view ? view.selectRecords() : null;
    const records = useRecords(queryResult);

    const summaryText = view
        ? `${view.name} has ${records.length} record(s).`
        : 'No view selected.';
    return (
        <Fragment>
            <p style={{marginBottom: 16}}>{summaryText}</p>
            <label style={{display: 'block', marginBottom: 16}}>
                <div style={{marginBottom: 8, fontWeight: 500}}>Table</div>
                <TablePicker
                    table={table}
                    onChange={newTable => {
                        setTable(newTable);
                        setView(null);
                    }}
                    shouldAllowPickingNone={true}
                />
            </label>
            {table && (
                <label>
                    <div style={{marginBottom: 8, fontWeight: 500}}>View</div>
                    <ViewPicker
                        table={table}
                        view={view}
                        onChange={newView => setView(newView)}
                        allowedTypes={[viewTypes.GRID]}
                        shouldAllowPickingNone={true}
                    />
                </label>
            )}
        </Fragment>
    );
}
```

#### ViewPickerProps

Type: [object][65]

##### Properties

-   `table` **[Table][78]?** The parent table model to select views from. If `null` or `undefined`,
    the picker won't render.
-   `view` **[View][74]?** The selected view model.
-   `onChange` **[function][64]?** A function to be called when the selected view changes.
-   `disabled` **[boolean][62]?** If set to `true`, the user cannot interact with the picker.
-   `allowedTypes` **[Array][61]&lt;ViewType>?** An array indicating which view types can be
    selected.
-   `shouldAllowPickingNone` **[boolean][62]?** If set to `true`, the user can unset the selected
    view.
-   `placeholder` **[string][60]?** The placeholder text when no view is selected.
-   `id` **[string][60]?** The ID of the picker element.
-   `className` **[string][60]?** Additional class names to apply to the picker.
-   `style` **[object][65]?** Additional styles to apply to the picker.
-   `tabIndex` **([number][66] \| [string][60])?** Indicates if the picker can be focused and
    if/where it participates in sequential keyboard navigation.
-   `aria-labelledby` **[string][60]?** A space separated list of label element IDs.
-   `aria-describedby` **[string][60]?** A space separated list of description element IDs.

#### ViewPickerSynced

**Extends React.Component**

Dropdown menu component for selecting views, synced with [GlobalConfig][3].

##### Parameters

-   `props` **[ViewPickerSyncedProps][152]**

##### Examples

```javascript
import {
    TablePickerSynced,
    ViewPickerSynced,
    useBase,
    useRecords,
    useWatchable,
} from '@airtable/blocks/ui';
import {viewTypes} from '@airtable/blocks/models';
import {globalConfig} from '@airtable/blocks';
import React, {Fragment} from 'react';

function Block() {
    const base = useBase();
    const tableId = globalConfig.get('tableId');
    const table = base.getTableByIdIfExists(tableId);
    const viewId = globalConfig.get('viewId');
    const view = view.getViewByIdIfExists(viewId);
    const queryResult = view ? view.selectRecords() : null;
    const records = useRecords(queryResult);
    useWatchable(globalConfig, ['tableId', 'viewId']);

    const summaryText = view
        ? `${view.name} has ${records.length} record(s).`
        : 'No view selected.';
    return (
        <Fragment>
            <p style={{marginBottom: 16}}>{summaryText}</p>
            <label style={{display: 'block', marginBottom: 16}}>
                <div style={{marginBottom: 8, fontWeight: 500}}>Table</div>
                <TablePickerSynced globalConfigKey="tableId" shouldAllowPickingNone={true} />
            </label>
            {table && (
                <label>
                    <div style={{marginBottom: 8, fontWeight: 500}}>View</div>
                    <ViewPickerSynced
                        table={table}
                        globalConfigKey="viewId"
                        allowedTypes={[viewTypes.GRID]}
                        shouldAllowPickingNone={true}
                    />
                </label>
            )}
        </Fragment>
    );
}
```

#### ViewPickerSyncedProps

Type: [object][65]

##### Properties

-   `table` **[Table][78]?** The parent table model to select views from. If `null` or `undefined`,
    the picker won't render.
-   `globalConfigKey` **[GlobalConfigKey][130]** A string key or array key path in
    [GlobalConfig][3]. The selected view will always reflect the view id stored in `globalConfig`
    for this key. Selecting a new view will update `globalConfig`.
-   `onChange` **[function][64]?** A function to be called when the selected view changes. This
    should only be used for side effects.
-   `disabled` **[boolean][62]?** If set to `true`, the user cannot interact with the picker.
-   `allowedTypes` **[Array][61]&lt;ViewType>?** An array indicating which view types can be
    selected.
-   `shouldAllowPickingNone` **[boolean][62]?** If set to `true`, the user can unset the selected
    view.
-   `placeholder` **[string][60]?** The placeholder text when no view is selected.
-   `id` **[string][60]?** The ID of the picker element.
-   `className` **[string][60]?** Additional class names to apply to the picker.
-   `style` **[object][65]?** Additional styles to apply to the picker.
-   `tabIndex` **([number][66] \| [string][60])?** Indicates if the picker can be focused and
    if/where it participates in sequential keyboard navigation.
-   `aria-labelledby` **[string][60]?** A space separated list of label element IDs.
-   `aria-describedby` **[string][60]?** A space separated list of description element IDs.

### ViewportConstraint

#### ViewportConstraint

**Extends React.Component**

-   **See: sdk.viewport**

ViewportConstraint - when mounted, applies constraints to the viewport.

##### Examples

```javascript
import {ViewportConstraint} from '@airtable/blocks/ui';
<ViewportConstraint minSize={{width: 400}} />;
```

```javascript
import {ViewportConstraint} from '@airtable/blocks/ui';
<ViewportConstraint maxFullScreenSize={{width: 600, height: 400}}>
    <div>I need a max fullscreen size!</div>
</ViewportConstraint>;
```

#### ViewportConstraintProps

Type: {minSize: [ViewportSizeConstraintProp][153]?, maxFullscreenSize:
[ViewportSizeConstraintProp][153]?, children: React.Node?}

##### Properties

-   `minSize` **[ViewportSizeConstraintProp][153]?**
-   `maxFullscreenSize` **[ViewportSizeConstraintProp][153]?**
-   `children` **React.Node?**

#### ViewportSizeConstraintProp

Type: {width: ([number][66] | null)?, height: ([number][66] | null)?}

##### Properties

-   `width` **([number][66] | null)?**
-   `height` **([number][66] | null)?**

[1]: #airtableblocks
[2]: #sdk
[3]: #globalconfig
[4]: #settingsbutton
[5]: #viewport
[6]: #airtableblocksmodels
[7]: #fieldtypes
[8]: #generateguid
[9]: #viewtypes
[10]: #recordcoloring
[11]: #abstractmodel
[12]: #abstractmodelwithasyncdata
[13]: #aggregator
[14]: #base
[15]: #session
[16]: #cursor
[17]: #field
[18]: #recordqueryresult
[19]: #record
[20]: #table
[21]: #view
[22]: #viewmetadataqueryresult
[23]: #watchable
[24]: #airtableblocksui
[25]: #initializeblock
[26]: #css--external-scripts
[27]: #color-utilities
[28]: #react-hooks-for-working-with-airtable-data
[29]: #expandrecord
[30]: #expandrecordlist
[31]: #expandrecordpickerasync
[32]: #autocompletepopover
[33]: #button
[34]: #cellrenderer
[35]: #choicetoken
[36]: #collaboratortoken
[37]: #colorpalette
[38]: #confirmationdialog
[39]: #dialog
[40]: #fieldpicker
[41]: #icon
[42]: #input
[43]: #link
[44]: #loader
[45]: #popover
[46]: #progressbar
[47]: #recordcard
[48]: #select
[49]: #selectbuttons
[50]: #tablepicker
[51]: #toggle
[52]: #tooltip
[53]: #viewpicker
[54]: #viewportconstraint
[55]: #usebase
[56]: #usesession
[57]: SettingsButton
[58]: https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage
[59]: https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage
[60]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String
[61]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array
[62]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean
[63]: #globalconfigvalue
[64]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/function
[65]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object
[66]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number
[67]: #viewportaddmaxfullscreensize
[68]: #viewportminsize
[69]: https://www.iso.org/iso-8601-date-and-time-format.html
[70]: #fieldtypesdate
[71]: #fieldtypesdate_time
[72]: https://airtable.com/universe
[73]: #field
[74]: #view
[75]: recordColoring.modes
[76]: #record
[77]: getCollaboratorByIdIfExists
[78]: #table
[79]: getTableByIdIfExists
[80]: getTableByNameIfExists
[81]: #aggregator
[82]: #tableorviewqueryresult
[83]: #linkedrecordsqueryresult
[84]: https://support.airtable.com/hc/en-us/articles/206452848-Linked-record-fields
[85]: #userecords
[86]: #userecordids
[87]: #userecordbyid
[88]: #useloadable
[89]: #color
[90]: #color
[91]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise
[92]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Date
[93]: #linkedrecordsqueryresult
[94]: getFieldByIdIfExists
[95]: getFieldByNameIfExists
[96]: getViewByIdIfExists
[97]: getViewByNameIfExists
[98]: #tableorviewqueryresult
[99]: #viewmetadataqueryresult
[100]: #useviewmetadata
[101]: https://developer.mozilla.org/docs/Web/API/HTMLStyleElement
[102]: https://developer.mozilla.org/docs/Web/API/HTMLLinkElement
[103]: https://developer.mozilla.org/docs/Web/API/HTMLScriptElement
[104]: #colors
[105]: #rgb
[106]: #rgb
[107]: https://reactjs.org/docs/hooks-intro.html
[108]: #withhooks
[109]: #usewatchable
[110]: #base
[111]: #globalconfig
[112]: #session
[113]: #viewport
[114]: #useviewport
[115]: #watchable
[116]: https://reactjs.org/docs/react-api.html#reactsuspense
[117]: #cursor
[118]: https://reactjs.org/docs/forwarding-refs.html
[119]: #autocompletepopoverprops
[120]: #autocompleteitem
[121]: #buttonprops
[122]: #cellrendererprops
[123]: #choicetokenprops
[124]: #collaboratortokenprops
[125]: #confirmationdialogprops
[126]: #dialogprops
[127]: #dialogclosebuttonprops
[128]: #fieldpickerprops
[129]: #fieldpickersyncedprops
[130]: #globalconfigkey
[131]: #iconprops
[132]: https://airtable.com/styleguide
[133]: #fieldiconprops
[134]: #inputprops
[135]: #inputsyncedprops
[136]: https://www.owasp.org/index.php/Reverse_Tabnabbing
[137]: #linkprops
[138]: #loaderprops
[139]: #popoverprops
[140]: #progressbarprops
[141]: #recordcardprops
[142]: #expandrecordopts
[143]: #selectprops
[144]: #selectoption
[145]: #selectsyncedprops
[146]: #tablepickerprops
[147]: #tablepickersyncedprops
[148]: #toggleprops
[149]: #togglesyncedprops
[150]: #tooltipprops
[151]: #viewpickerprops
[152]: #viewpickersyncedprops
[153]: #viewportsizeconstraintprop
